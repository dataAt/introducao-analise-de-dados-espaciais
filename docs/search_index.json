[
["introducao.html", "1 Introdução", " 1 Introdução "],
["revisao-bibliografica.html", "2 Revisão bibliográfica 2.1 Representações de dados espaciais 2.2 Sistema de referência espacial 2.3 Projeções cartográficas 2.4 Sistema de Coordenadas 2.5 Open Geospatial Consortium (OGC) 2.6 Tipos e operações espaciais 2.7 Matriz de 9-intersecções Estendida dimensionalmente 2.8 Relacionamentos espaciais nomeados", " 2 Revisão bibliográfica Nesta seção os principais conceitos necessários para a realização de análises de dados espaciais serão feitos. Todo o conteúdo abaixo foi criado buscando ser o mais simples, direto e didático possível. 2.1 Representações de dados espaciais 2.1.1 Vetoriais 2.1.2 Matriciais 2.2 Sistema de referência espacial Bem, como vimos até aqui, dados espaciais possuem duas características fundamentais, o registro de diferentes fenômenos e sua localização. Mas como esta localização é vinculada a uma posição da superfície terrestre? Para conseguirmos responder a esta pergunta devemos ir por partes. Vamos começar imaginando uma superfície plana, como a apresentada abaixo. Agora perceba que, para gerar tal superfície o que precisou ser feito foi delimitar quatro pontos e então ligar cada um deles, veja. Até aqui apenas criamos uma superfície e delimitamos seu espaço através dos pontos ABCD, vamos agora inserir valores para os lados desta superfície. Lembre-se que, está superfície representa um quadrado, e assim, todos os seus lados têm o mesmo tamanho. Certo! Com os limites definidos podemos agora adicionar um ponto nesta superfície, isto porque, se cada um dos lados vai de 0 a 10, conseguimos facilmente inserir um ponto utilizando os lados como referência. Ok, mas, o que é isso tem a ver com sistemas de referência espacial e nossa pergunta inicial? Tudo! Isto já que, para sabermos onde estava o ponto e sua localização precisamos definir os limites da superfície, e a mesma situação é necessária para os dados espaciais e a superfície terrestre. Então, com a mesma lógica aplicada a superfície quadrada do exemplo anterior podemos mapear todo o planeta Terra, porém alguns problemas surgem para este caso. Primeiro, para começarmos a mapear a superfície terrestre devemos entender: Como é a superfície terrestre; e formas de representação. Começando com a superfície terrestre, as ciências geodésicas, que se empenham em realizar os estudos das formas e dimensões da Terra dividem sua superfície em três formas diferentes (Montanari 2014). Na Figura acima o geóide representa tudo que está no nível do mar, o elipsoide representa a camada abaixo do geóide e o terreno a parte superior ao geóide, além disto, tanto a representação da superfície terrestre quanto o geóide carregam diversas dificuldades quando precisam ser representados, por conta de suas características irregulares, por isto, adota-se como representação da superfície, o elipsoide. Com isto, pode-se concluir que, o geóide é a superfície de medição da Terra, enquanto o elipsoide é a superfície de representação. Certo, com a definição da forma de representação da superfície terrestre já podemos realizar todo o mapeamento, correto? Ainda não, pois além de entendermos como é a superfície precisamos definir como toda esta superfície terrestre será representada. Tal representação pode ser feita de diversas formas, a variar de acordo com a necessidade, algumas dessas formas são apresentadas na Figura abaixo. Onde, a superfície esférica normalmente é utilizada como representação da Terra quando há grandes quantidades de área a serem representadas, como por exemplo, diversos continentes ou mesmo o planeta todo (Montanari 2014) . Já para os casos, onde é necessário a representação de uma quantidade de Terra considerável, porém, não tão grande como o planeta todo, utiliza-se a representação elipsóidica (Montanari 2014), esta que inclusive é a mais utilizada nas aplicações espaciais atuais. Por fim, tem-se o modelo geoidal, que como já citado, é o que mais se aproxima da superfície terrestre, porém sua representação pode ser muito complexa para o mapeamento da superfície terrestre e a geração das localizações. Beleza! Agora entendemos todo o fluxo necessário para realizar do mapeamento, partindo da definição da superfície e indo até suas formas de representação. Com isto, conseguimos fazer uma definição de sistemas de referência espacial que seja clara e concisa. Sistemas de referência espacial, ou DATUM, é um sistema coordenado, utilizado para representar características físicas e geométricas do planeta Terra. Alguns exemplos de sistemas de referência espacial são: WGS 84; Sirgas 2000. Muito interessante, porém, mesmo com este entendimento ficou uma dúvida, como é que os pontos vão ser representados, da mesma forma que havíamos feito no exemplo? Bem, esta pergunta é respondida nas seções seguintes. 2.3 Projeções cartográficas Até esta seção, todas as informações passadas de representações da superfície terrestre utilizaram modelos tridimensionais para tal feito, porém, se estas representações possuem três dimensões, como mapas bidimensionais, com o apresentado abaixo são gerados? A resposta é simples! Projeções cartográficas, estas que através de transformações geométricas realizam a conversão das representações tridimensionais para bidimensionais, mantendo a correspondência entre ambas IBGE (2016a). 2.3.1 Tipos de projeção Por se tratar de operações geométricas é esperado que nessas existam distorções (IBGE 2016a), por conta disto existem diferentes tipos de superfícies geométricas de projeção que são utilizadas (IBGE 2016b), para que as superfícies no momento da projeção foram a menor quantidade possível de distorções nas áreas de interesse. As subseções a seguir apresentam alguns tipos de superfícies geométricas utilizadas para as projeções. 2.3.1.1 Projeção cilíndrica Na projeção cilíndrica o esferoide de representação da Terra é envolvido sobre um cilindro tangente. Neste tipo de projeção há muitas distorções dos polos, sul e norte, o que faz com que estes pareçam ter tamanhos bem maiores do que deveriam. 2.3.1.2 Projeção Cônica As projeções cônicas são geradas através da utilização de um cone, que favorece a redução de distorções nos meridianos e aumenta a distorção nos polos. 2.3.1.3 Projeção plana Projeção que é gerada com base em um plano, que toca em um ponto específico da representação da esfera terrestre. Como é possível perceber na Figura acima, neste tipo de projeção é esperado que haja muitas distorções no entorno do ponto utilizado como referência para sua criação. 2.4 Sistema de Coordenadas Bem, mesmo com as várias formas de representação e projeção, é mais que necessário utilizamos de alguma técnica que nos permita, dentro de cada uma das representações, apontar sem nenhum tipo de ambiguidade as posições nas quais diferentes objetos estão na superfície terrestre. 2.4.1 Sistemas de Coordenadas Geográficas Então, para que cada objeto na superfície da Terra fosse facilmente identificado, sem nenhum tipo de ambiguidade, um sistema de linhas imaginárias, nomeado de Sistemas de Coordenadas Geográficas foi criado. Neste sistema existem dois tipos de linhas, os meridianos e os paralelos. Para os meridianos tem-se que são linhas imaginárias que cortam a Terra no sentido norte-sul e para os paralelos, tem-se linhas que circulam a Terra no sentido leste-oeste (IBGE 2016b). Vale acrescentar também que, os paralelos nos representam as latitudes, que são a distância em graus da linha do Equador até um determinado paralelo. Os valores da latitude podem variar de 0° (Sob a linha do Equador) a 90° (Sob as extremidades), sendo que, para os hemisférios norte são considerados valores positivos e para o hemisfério sul valores negativos. Já as longitudes representam a distância, em graus, entre o meridiano de Greenwich até um outro meridiano qualquer. Seus valores variam de 0° (Sob o meridiano de Greenwich) a 180° (Nas extremidades leste e oeste a Greenwich), onde, para o leste consideram-se valores positivos e ao oeste valores negativos (IBGE 2016b). A representação de todo este sistema imaginário de linhas pode ser visto na Figura abaixo. 2.4.2 Coordenadas planas Outra forma de realizar o mapeamento das posições das representações das superfícies terrestres é feita com o método nomeado de Coordenadas planas, que de acordo com Santos, Barbosa, and Gomes (2016) são recomendados para atividades de medições de áreas e distâncias. O sistema de coordenadas planas é baseado no sistema cartesiano de representação, onde em um plano bidimensional o cruzamento de duas linhas faz a representação da localização de um ponto (Santos, Barbosa, and Gomes 2016), sendo que o eixo X representa a Latitude e o eixo Y a longitude. Espere um pouco, representação em um plano? Até aqui vimos a representação geográfica que é feita sobre a representação esferoidal da superfície terrestre e só vimos a superfície plana nas projeções. Pois bem, para a utilização do sistema de coordenadas planas é assumido que alguma projeção seja aplicada, normalmente utiliza-se a superfície cônica na projeção dos dados para a utilização deste sistema (Santos, Barbosa, and Gomes 2016). Lembra do mercator que citamos anteriormente, a forma de representação para coordenadas planas comumente utilizada também é dele, e possui o nome de Sistema Universal Transversa de Mercator. 2.4.3 Códigos EPSG Os códigos European Petrolem Survey Group (EPSG) representam uma forma de organização dos mais diversos sistemas de referências e seus sistemas de coordenadas, desta forma os códigos EPSG criam uma forma rápida e simples para a busca e identificação de qual sistema de referência e sistema de coordenadas está sendo utilizado. Como estes códigos abrangem todos os sistemas de coordenadas do mundo, com os mais variados sistemas de coordenadas, abaixo é apresentado uma tabela com somente alguns dos códigos EPSG mais utilizados no Brasil. CÓDIGO EPSG PROJEÇÃO/DATUM 4225 GCS 4618 Corrego Alegre 4674 GCS SAD69 4326 GCS SIRGAS 22521 2000 22522 GCS WGS84 22523 Corrego 2.5 Open Geospatial Consortium (OGC) 2.6 Tipos e operações espaciais 2.7 Matriz de 9-intersecções Estendida dimensionalmente 2.8 Relacionamentos espaciais nomeados "],
["python.html", "3 Python ✨ 3.1 Pandas 🐼 3.2 GeoPandas 🌏🐼", " 3 Python ✨ Python é uma linguagem de programação versátil, multiparadigma, que permite aos desenvolvedores criar rápidas soluções para seus problemas sem grandes preocupações com a sintaxe e formas de uso da linguagem. Tais características fizem Python alcançar os mais variados nichos de aplicação. Por ser uma linguagem geral para atingir tais nichos, foram criadas pela comunidade de Python diversas bibliotecas, todas seguindo a ideia da simplicidade de aplicação e prototipação da linguagem. É neste contexto que surge o GeoPandas, que fornece extensões de uso espacial para uma biblioteca de análise de dados muito conhecida na comunidade Python, o Pandas. Desta forma, este capítulo busca explicar as principais formas de utilização do GeoPandas. Por ser baseada no Pandas, há uma pequena seção que trata sobre o uso básico da linguagem, mas é recomendado que o leitor também conheça tal biblioteca, para isto, existe o curso de introdução à análise de dados, que explica os principais conceitos de utilização do Pandas, não deixe de conferir! 3.1 Pandas 🐼 Com a necessidade de facilitar todo o processo de análise de dados, através de uma linguagem simples e amigável, a comunidade Python criou o Pandas, uma biblioteca que disponibiliza métodos de alto nível para a manipulação, processamento e análise dos mais variados tipos de dados. Através dos métodos desta biblioteca é possível aplicar todo o ciclo de análise de dados, este indo desde a coleta até o processamento e análise. Para realizar tais atividades, o pandas disponibiliza diversas estruturas de dados, sendo as Series e os DataFrames as principais. Cada uma dessas estruturas de dados, trata especificamente de uma forma de realizar a abstração do formato dos dados em código, isto faz com que seja necessário o entendimento das principais diferentes entre cada uma delas, para que seja possível realizar sua correta aplicação. Vamos buscar comparar cada uma dessas estruturas para entender suas diferenças. As Series são estruturas de dados unidimensionais, possuindo apenas uma dimensão que pode ser manipulada, tal dimensão sendo chamada de índice. Já os DataFrames apresentam duas dimensões para a manipulação. Estas características, na prática, indicam que, as Series apenas representar vetores, enquanto os DataFrames podem representar matrizes de N-Dimensões. Para esta ideia ficar clara, vejamos a Figura abaixo. Perceba que, as Series possuem o campo para o armazenamento dos dados (Representado em Azul), e o índice (Representado em roxo), não podendendo ser adicionado nenhum outro campo, isto faz com que, todos os dados tenham de ser armazenados em apenas uma coluna, em várias linhas. Para o DataFrame o cenário apresentado na Figura é diferente, além dos índices, há também as colunas (Representada em vermelho), o que permite que dentro desta estrutura existam não só um conjunto de linhas, como as Series mas sim um conjunto de colunas, onde cada uma dessas possuem várias linhas. Na prática o que fica subentendido é que, os DataFrames são um conjunto de Series. Isto ocorre já que, cada uma das colunas criadas dentro do DataFrame são Series, o que acaba gerando um efeito muito interessante na API do Pandas, boa parte dos métodos disponíveis para as Series também estão presentes nos DataFrames. Vamos ver alguns exemplos em código para fixar a diferença entre essas duas estruturas de dados. 3.1.1 Manipulação de dados Vamos começar criando uma Series. import pandas as pd sr = pd.Series([1, 2, 3, 4, 5]) Pronto! Acabamos de criar uma Series com uma lista de valores, vejamos como ela está sendo representada. print(sr) ## 0 1 ## 1 2 ## 2 3 ## 3 4 ## 4 5 ## dtype: int64 A representação está da mesma forma que vimos antes. Vamos agora fazer uma pequena manipulação dos dados, para isto, utilizaremos os métodos loc e iloc disponíveis dentro do objeto Series gerado, onde o método loc busca o índice com o nome inserido e o iloc busca o índice com a posição inserida. A assinatura de cada um dos métodos está descrita abaixo. Lembre-se que este método está presente tanto na classe Series como na classe DataFrame. DataFrame Series .loc[linha, coluna] .loc[linha] .iloc[linha] .iloc[linha] Antes de fazermos o teste destes métodos, vamos alterar o índice da nossa Series. # Vamos visualizar o índice print(sr.index) ## RangeIndex(start=0, stop=5, step=1) O atributo index devolve os elementos que estão no índice, para fazer sua mudança, basta realizar uma atribuição, veja. sr.index = [&quot;um&quot;, &quot;dois&quot;, &quot;tres&quot;, &quot;quatro&quot;, &quot;cinco&quot;] print(sr.index) ## Index([&#39;um&#39;, &#39;dois&#39;, &#39;tres&#39;, &#39;quatro&#39;, &#39;cinco&#39;], dtype=&#39;object&#39;) Fizemos esta mudança, para que cada um dos métodos loc e iloc seja mais simples de entender. Certo, vamos começar buscando a linha que tenha o nome dois. print(sr.loc[&quot;dois&quot;]) ## 2 Agora vamos buscar a linha que está na posição dois. print(sr.iloc[1]) # Lembre-se, o Python começa a contar no zero =D ## 2 Percebeu? Temos o mesmo resultado, muito interessante não ? Além disso ainda posso aplicar filtros sob os dados,utilizando o conceito de indexação booleana, onde através de um vetor de VERDADEIRO e FALSO é possível selecionar as linhas. Vamos buscar somente os valores que são acima de três. print(sr[sr &gt; 3]) ## quatro 4 ## cinco 5 ## dtype: int64 Dica: O que ocorre nesta parte é, dentro das chaves de sr (sr[]) é passado a expressão sr &gt; 3 que devolve uma lista de verdadeiros e falsos, fazendo assim o filtro. Muito interessante! Mas até aqui trabalhamos com apenas uma dimensão, vamos tentar acrescentar mais, para isto, primeiro vamos criar uma matriz. matriz = [ [1, 2, 3], [4, 5, 6] ] A matriz criada é representada por uma lista de listas. Vamos tentar criar uma Series com esta matriz. sr = pd.Series(matriz) print(sr) ## 0 [1, 2, 3] ## 1 [4, 5, 6] ## dtype: object Eita! Perceba que, em cada linha há uma lista de valores, o que é ruim! Já que a manipulação fica difícil (Tenta fazer uma indexação booleana, vai falhar 😢). Para este caso, existem os DataFrames! Vamos começar criando um com a mesma matriz gerada anteriormente. df = pd.DataFrame(matriz) print(df) ## 0 1 2 ## 0 1 2 3 ## 1 4 5 6 Opa! Agora o cenário é outro, conseguimos colocar cada um dos valores em seu devido lugar. Perceba que a representação mudou bastante, aqui temos várias colunas de dados, e mesmo assim, todos os métodos já apresentados até aqui funcionam. Vai lá, tenta! Uma coisa importante sobre os DataFrames são suas colunas, para acessar elas podemos fazer da seguinte forma. print(df[0]) ## 0 1 ## 1 4 ## Name: 0, dtype: int64 Viu! Estamos acessando a primeira coluna, se fizermos a mesma coisa, com a segunda também vai funcionar (Tenta inserir o número 1, para você ver o que acontece). Dica: Ao fazer df[0], estamos buscando o “nome” da coluna, e não sua posição Da mesma forma que eu podemos recuperar o índice com o atributo index podemos recuperar as colunas com o atributo columns print(df.columns) ## RangeIndex(start=0, stop=3, step=1) Para fazer a mudança dos nomes de cada coluna a mesma regra do index é válida. df.columns = [&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;] print(df.columns) ## Index([&#39;col1&#39;, &#39;col2&#39;, &#39;col3&#39;], dtype=&#39;object&#39;) Vamos recuperar a primeira coluna novamente print(df[&quot;col1&quot;]) ## 0 1 ## 1 4 ## Name: col1, dtype: int64 Assim, fica mais fácil entender que, quando se trata de colunas, estamos buscando os nomes, e não simplesmente as posições. Bom, agora que já entendemos toda a utilização básica do Pandas, vamos começar a falar um pouco sobre o GeoPandas 💜 3.2 GeoPandas 🌏🐼 Com o entendimento do que é a biblioteca Pandas, suas estruturas de dados e principais características, o estudo do GeoPandas pode ser iniciado. Mas o que é o GeoPandas ? GeoPandas é um projeto open-source que busca facilitar o trabalho com dados vetoriais em Python, para isto, tem como base as estruturas de dados do Pandas Desta forma, a ideia básica por trás do GeoPandas é adicionar o suporte a manipulação de dados espaciais as estruturas de dados do Pandas, e com isto prover formas de manipulação simples e direta a tais dados. Para fazer isto, o GeoPandas utiliza estruturas de dados geométricas implementadas pela biblioteca Shapely dentro das Series e dos DataFrames. Com esta adição, duas estruturas de dados surgem, as GeoSeries e os GeoDataFrames. Este conceito pode ser melhor entendido com a observação da Figura abaixo. Perceba que, há a mesma estrutura que foi apresentada na seção anterior, com as geometrias sendo o diferencial nas estruturas de dados. Na prática o que ocorre é, todas as formas de manipulação geométricas, que como citadas são implementadas com o Shapely, são implementadas em uma classe GeoPandasBase que é extendida pelas GeoSeries e GeoDataFrames, da mesma forma, essas também extendem as estruturas de dados equivalentes do Pandas, veja a Figura abaixo. Como a GeoSeries e os GeoDataFrames são especializações diretas das Series e dos DataFrames as mesmas características são mantidas, onde, respectivamente, um armazena apenas uma coluna de valores, tendo uma dimensão de manipulação e o outro armazena diversas colunas com duas dimensões de manipulação, da mesma forma como apresentado na seção anterior. Para fixar o funcionamento de cada uma dessas estruturas, vamos fazer alguns testes com a API do GeoPandas. 3.2.1 GeoSeries e GeoDataFrames Para começar os testes, vamos importar a biblioteca de geometrias, Shapely e o GeoPandas. import shapely import geopandas as gpd Agora, vamos criar uma GeoSeries. gsr = gpd.GeoSeries([ shapely.geometry.Point(1, 1) ]) Dica: A geometria criada não possui qualquer tipo de referência espacial, portanto representa apenas um ponto no plano cartesiano. Veja que acabamos de criar uma GeoSeries que armazena uma geometria de ponto, vamos visualizar o objeto criado. print(gsr) ## 0 POINT (1.00000 1.00000) ## dtype: geometry A forma é exatamente a mesma de uma Series. Vamos criar um novo objeto com mais geometrias inseridas. gsr = gpd.GeoSeries([ shapely.geometry.Point(1, 1), shapely.geometry.Point(2, 2), shapely.geometry.Point(4, 3) ]) print(gsr) ## 0 POINT (1.00000 1.00000) ## 1 POINT (2.00000 2.00000) ## 2 POINT (4.00000 3.00000) ## dtype: geometry Caso eu queira visualizar não só a tabela, mas sim a representação das geometrias criadas no espaço, é possível utilizar o método plot. gsr.plot() Mas as GeoSeries podem ser limitadas em alguns casos, imagine que para a realização de um estudo seja necessário não só a geolocalização ou a representação geométrica no espaço, mas também características do ambiente, qualquer tipo de informação que não a espacial. Nestes casos podemos utilizar os GeoDataFrames que além de colunas de geometria permitem o armazenamento de outras informações, isto por permitir multiplas colunas. Vamos criar um para fazer testes. gdf = gpd.GeoDataFrame({ &#39;atributo_a&#39;: [10, 11, 12], &#39;geometria&#39;: [ shapely.geometry.Point(1, 1), shapely.geometry.Point(2, 2), shapely.geometry.Point(4, 3) ] }) Visualizando o resultado print(gdf) ## atributo_a geometria ## 0 10 POINT (1 1) ## 1 11 POINT (2 2) ## 2 12 POINT (4 3) Agora as geometrias passam a ser vinculadas com outros valores, o que pode ser muito útil em vários cenários. Até aqui foram criadas geometrias sem nenhum tipo de ligação com o mundo real, então, vamos agora trabalhar um pouco com dados que façam esta representação, para isto, vejamos como carregar dados espaciais com o GeoPandas. 3.2.2 Leitura e escrita de dados Além de todas as características citadas até aqui, o GeoPandas ainda ajuda na leitura e na escrita de dados vetoriais, tudo seguindo o padrão de facilidade de uso do Pandas. Para realizar essas operações o GeoPandas utiliza como base a biblioteca Fiona, que traz suporte a leitura e escrita de uma enorme variedade de formatos vetoriais, sendo alguns deles: GeoJSON; GPSTrackMaker; ESRI Shapefile; FileGDB; OpenFileGDB. Além destes formatos a biblioteca aceita vários outros, para a lista completa de formatos suportados, consulte a documentação do Fiona. Para fazer alguns testes utilizando as funcionalidades de leitura dos dados, vamos carregar um dado vetorial, dos estados do Brasil que estão armazenados em um shapefile. gdf = gpd.read_file(&quot;../data/1_estados_do_brasil_shape/Brasil.shp&quot;) Estes dados estão disponíveis no repositório do curso. Com os dados carregados, vamos visualizar qual foi a estrutura gerada ao carregar os dados. print(type(gdf)) ## &lt;class &#39;geopandas.geodataframe.GeoDataFrame&#39;&gt; Um GeoDataFrame! Isto é feito por padrão pela biblioteca, assim, independente do formato de entrada, o GeoPandas busca inserir os dados dentro de um GeoDataFrame. Certo, vamos olhar então o que está dentro deste objeto. print(gdf.head(5)) ## ESTADOS REGIAO COD_UF UF geometry ## 0 Acre Norte 12.0 AC POLYGON ((-73.80098 -7.11145, -73.74084 -7.143... ## 1 Alagoas Nordeste 27.0 AL MULTIPOLYGON (((-36.39119 -10.50082, -36.39864... ## 2 Amapá Norte 16.0 AP MULTIPOLYGON (((-51.37380 -0.37053, -51.37337 ... ## 3 Amazonas Norte 13.0 AM POLYGON ((-73.80098 -7.11145, -73.80106 -7.111... ## 4 Bahia Nordeste 29.0 BA MULTIPOLYGON (((-46.32975 -13.25248, -46.33072... É possível perceber neste resultado que, ao carregar os dados, as representações espaciais presentes no arquivo, foram inseridas em uma coluna chamada geometry e que, além dessa coluna, existem outras que vinculam múltiplas informações a cada uma das representações espaciais presentes no arquivo. Lembre-se, o método head é herdado do Pandas, ele possibilita a visualização das linhas iniciais da tabela de dados. A representação acima não nos mostra todas as colunas de informações que temos no conjunto de dados carregados, para saber quais são todas elas, utilizaremos o atributo columns. print(gdf.columns) ## Index([&#39;ESTADOS&#39;, &#39;REGIAO&#39;, &#39;COD_UF&#39;, &#39;UF&#39;, &#39;geometry&#39;], dtype=&#39;object&#39;) Olha que interessante! Para cada estado, há seu nome, a região a que pertence, sua Unidade da Federação (UF) e o código desta UF. Agora que já sabemos como estão nossos dados, vamos voltar um pouco na coluna geometry. print(gdf[&quot;geometry&quot;].head(5)) ## 0 POLYGON ((-73.80098 -7.11145, -73.74084 -7.143... ## 1 MULTIPOLYGON (((-36.39119 -10.50082, -36.39864... ## 2 MULTIPOLYGON (((-51.37380 -0.37053, -51.37337 ... ## 3 POLYGON ((-73.80098 -7.11145, -73.80106 -7.111... ## 4 MULTIPOLYGON (((-46.32975 -13.25248, -46.33072... ## Name: geometry, dtype: geometry Entenda, a geometria escolhida para representar cada um dos estados do Brasil foi o poligono, e isto é possível de visualizar na coluna geometry. Outro fato importante sobre esta coluna é que, ela não precisa ter este nome, ele é definido automaticamente pelo GeoPandas para que as coisas sejam padronizadas e fiquem mais simples, mas, caso eu queira alterar, posso fazer isto facilmente da seguinte forma. gdf = gdf.rename_geometry(&quot;geometria&quot;) Ao fazer isto, vamos visualizar as colunas do GeoDataFrame alterado. print(gdf.columns) ## Index([&#39;ESTADOS&#39;, &#39;REGIAO&#39;, &#39;COD_UF&#39;, &#39;UF&#39;, &#39;geometria&#39;], dtype=&#39;object&#39;) Mas, e se nos dados que eu estiver carregando existirem mais de uma coluna de representações espaciais, como o GeoPandas entende qual deve ser utilizada? Bem, por padrão ele escolhera a primeira delas e a tratará como a coluna geometry do conjunto de dados, porém se eu quiser fazer a alteração, também é possível. Primeiro, vamos aprender a identificar como o GeoPandas mostra a coluna que ele está utilizando como padrão, para isto o atributo geometry é utilizado. print(gdf.geometry.head(5)) ## 0 POLYGON ((-73.80098 -7.11145, -73.74084 -7.143... ## 1 MULTIPOLYGON (((-36.39119 -10.50082, -36.39864... ## 2 MULTIPOLYGON (((-51.37380 -0.37053, -51.37337 ... ## 3 POLYGON ((-73.80098 -7.11145, -73.80106 -7.111... ## 4 MULTIPOLYGON (((-46.32975 -13.25248, -46.33072... ## Name: geometria, dtype: geometry Este atributo devolve os dados da coluna padrão de geometrias. Vamos ver qual é o nome da coluna de onde ele retira tais dados. print(gdf.geometry.name) ## geometria O nome é exatamente o mesmo da coluna que renomeamos! Vamos trocar esta coluna padrão, para fazer este teste, vou duplicar a coluna que contém as geometrias, porém cada uma terá um nome. gdf[&quot;geometria_dois&quot;] = gdf[&quot;geometria&quot;] print(gdf.columns) ## Index([&#39;ESTADOS&#39;, &#39;REGIAO&#39;, &#39;COD_UF&#39;, &#39;UF&#39;, &#39;geometria&#39;, &#39;geometria_dois&#39;], dtype=&#39;object&#39;) Feito isto, vamos alterar a coluna padrão de geometrias gdf = gdf.set_geometry(&quot;geometria_dois&quot;) Ao visualizar o resultado, percebemos que a mudança foi realizada com sucesso. print(gdf.geometry.name) ## geometria_dois A diferença entre o método rename_geometry e set_geometry está no ponto em que, a set_geometry altera a coluna que está sendo considerada como padrão para geometrias, equanto a rename_geometry altera o nome da coluna padrão de geometrias. Por fim, vamos visualizar a disposição destes dados em uma figura, para isto, utilizamos o método plot. gdf.plot() O ponto a ser entendido do método plot é que, ele utiliza a coluna de geometrias padrão para gerar a figura, então, caso haja alguma inconsistência neste coluna este método terá problemas. Esta lógica se aplica a todos os outros métodos do GeoPandas que utilizam a representação espacial para fazer as operações. Vamos salvar os resultados em um arquivo shapefile, para isto, façamos a utilização do método to_file. del gdf[&quot;geometria&quot;] # Removendo coluna extra de geometrias gdf.to_file(&#39;tmp/estados_do_brasil_editado.shp&#39;) Não deixe de consultar a documentação do Pandas e do GeoPandas, por conta das bibliotecas trabalharem juntas, muitos formas de dados podem ser escritos e tratados, no GeoPandas é possível até mesmo ler dados diretamente de um banco de dados espacial (PostGres com PostGIS). 3.2.3 Manipulação geométrica O GeoPandas oferece diferentes métodos para a manipulação dos dados espaciais carregados, esta seção fará a apresentação de alguns destes métodos. É importante lembrar que, todos estes métodos estão orientados a coluna de geometria padrão, vista na subseção anterior. As operações apresentadas nas subseções a seguir, são representadas por métodos e atributos das GeoSeries e dos GeoDataFrames. 3.2.3.1 area Vamos começar com as operações de área, que de forma análoga ao nome, cálcula a área da geometria em questão. Vejamos a Figura abaixo que faz uma representação desta operação em diferentes formas geométricas. O resultado da operação, devolve o cálculo da área, representado em vermelho na Figura acima. Para exemplificar, vamos utilizar o conjunto de dados dos estados do Brasil estados_do_brasil = gpd.read_file(&quot;../data/1_estados_do_brasil_shape/Brasil.shp&quot;) Lembre-se, este conjunto de dados está disponível no repositório do curso Depois de carregar os dados, vamos utilizar o atributo area, que realiza a operação e devolve a àrea para cada uma das linhas do conjunto de dados print(estados_do_brasil.area.head(5)) # Exibindo somente as 5 primeiras ## 0 12.553132 ## 1 2.285972 ## 2 11.424936 ## 3 128.108383 ## 4 46.911114 ## dtype: float64 A área é devolvida na unidade de medida da projeção espacial utilizada no conjunto de dados, estes detalhes serão apresentados nas seções seguintes. 3.2.3.2 bounds O atributo bounds devolve as coordenadas mínimas e máximas da região coberta pela geometria. Sua representação é feita na Figura abaixo. Perceba que, para cada figura é criado um retângulo que a envolve (Também chamado de retângulo envolvente) e as coordenadas mínimas e máximas são retiradas desses. Vejamos um exemplo print(estados_do_brasil.bounds.head(5)) ## minx miny maxx maxy ## 0 -73.990943 -11.144489 -66.619331 -7.111453 ## 1 -38.237442 -10.500822 -35.151669 -8.812208 ## 2 -54.875779 -1.235830 -49.875779 4.437122 ## 3 -73.801055 -9.814097 -56.097385 2.247063 ## 4 -46.629029 -18.349041 -37.339928 -8.532272 3.2.3.3 centroid O atributo centroid devolve o ponto central da geometria. Sua representação é feita na Figura abaixo. O ponto retornado para cada geometria é apresentado em vermelho. Vejamos um exemplo com o GeoPandas. centroids_dos_estados = estados_do_brasil.centroid Se olharmos para o resultado teremos uma GeoSeries com um ponto para cada um dos estados, vamos visualizar estes pontos rapidamente. centroids_dos_estados.plot() Para fazermos um pequeno experimento, famos pegar a figura com os estados e fazer seu plot junto com os centroids. base = estados_do_brasil.plot() centroids_dos_estados.plot(ax=base, marker=&quot;o&quot;, color=&quot;red&quot;) 3.2.3.4 buffer O método buffer cria um circulo entorno de um ponto, e pode ser aplicado em diferentes tipos de análises espaciais. Sua representação é feita na Figura abaixo. Para testar esta operação, vamos utilizar os centroids extraídos na seção anterior. buffers = centroids_dos_estados.buffer(2) Da mesma forma que outros métodos que trabalham com distâncias, os valores dependem diretamente das projeções espaciais utilizadas. Vamos fazer um plot do resultado gerado sob o mapa dos estados do Brasil. base = estados_do_brasil.plot() base = buffers.plot(ax = base, color = &#39;yellow&#39;) # Adicionando os centroids também, para testar =D centroids_dos_estados.plot(ax = base, color = &#39;red&#39;) 3.2.3.5 envelope Por fim, o método envelope cria o mesmo retângulo envolve utilizado no atributo bounds, com a diferença que, neste caso a geometria é devolvida. A representação desta operação é feita na Figura abaixo. Para testar, vamos pegar os buffers gerados anteriormente e então gerar seu retângulo envolvente. envelopes = buffers.envelope Da mesma forma que nos demais, vamos visualizar o resultado. base = estados_do_brasil.plot() envelopes.plot(ax = base, color = &#39;green&#39;) 3.2.4 Seleção e filtro de dados O GeoPandas ainda fornece métodos para a seleção e filtros de dados baseados na posição espacial. Nesta seção veremos dois desses, que podem ser muito úteis nas mais diversas análises. 3.2.4.1 distance Vamos começar com o método distance, que calcula a distância entre duas geometrias. Sua operação é representada na Figura abaixo. Para testar esta operação, vamos carregar dois dados vetoriais, cada um represetando um estado do Brasil. estado_maranhao = gpd.read_file(&quot;../data/2_estado_sp_shape/shape_estado-sp.shp&quot;) estado_saopaulo = gpd.read_file(&quot;../data/3_estado_ma_shape/shape_estado-ma.shp&quot;) Vamos visualizar os dois juntos. Nesta visualização, para ela ter sentido, abaixo dos estados foi fazer o plot do mapa do Brasil. base = estados_do_brasil.plot() base = estado_maranhao.plot(ax = base, color = &#39;green&#39;) estado_saopaulo.plot(ax = base, color = &#39;yellow&#39;) Certo, vamos calcular a distância entre cada um deles. distancia = estado_saopaulo.distance(estado_maranhao) print(distancia) ## 0 9.809695 ## dtype: float64 Feito, com isto tem-se a distância entre as duas geometrias, que neste caso representa os estados do Maranhão e São Paulo. Esta mesma operação pode ser utilizada como uma forma de consulta aos dados, por exemplo, buscar estados que estejam a X de distância de outro. 3.2.4.2 contains O método contains verifica se uma geometria está contida em outra, sua representação visual é apresentada abaixo . Vamos fazer um teste da operação com o estado do Amazonas, verificando se sua geometria está contida nas nos dados de estados do Brasil. Primeiro, vamos retirar do GeoDataFrame as informações do estado do Amazonas, para isto aplicaremos um filtro booleano, herdado do Pandas. estado_amazonas = estados_do_brasil[estados_do_brasil[&quot;ESTADOS&quot;] == &quot;Amazonas&quot;] # Indexação booleana Agora vamos verificar se o estado está contido em alguma geometria dos estados do Brasil. amazonas_esta_presente = estados_do_brasil.contains(estado_amazonas) print(amazonas_esta_presente.head(10)) ## 0 False ## 1 False ## 2 False ## 3 True ## 4 False ## 5 False ## 6 False ## 7 False ## 8 False ## 9 False ## dtype: bool Veja que em uma das linhas apareceu True, isto indica que a geometria do estado do Amazonas está contida nesta, que se formos olhar a linha do GeoDataFrame com os dados do estado, indica exatamente a linha do estado do Amazonas. print(estados_do_brasil[amazonas_esta_presente]) ## ESTADOS REGIAO COD_UF UF geometry ## 3 Amazonas Norte 13.0 AM POLYGON ((-73.80098 -7.11145, -73.80106 -7.111... 3.2.4.3 intersects Por fim, na parte de seleção através dos dados espaciais, vamos testar o método intersects, que verifica se uma geometria faz intersecção com outra. Vale lembrar que, é tido como uma intersecção, quando um objeto cruza de alguma maneira, seu limite e seu interior com outro objeto. A operação pode ser vista abaixo. Para realizar este teste, vamos carregar um arquivo que contém todos rios do nosso país. E então verificar quais desses fazem intersecção com o estado do Pará. rios_brasil = gpd.read_file(&quot;../data/4_rios_brasil/Brasil_rios.shp&quot;) Antes de continuar, vamos visualizar os dados, junto aos estados do Brasil. base = estados_do_brasil.plot(color = &quot;gray&quot;) rios_brasil.plot(ax = base, color = &#39;red&#39;) base = estados_do_brasil.plot(color = &quot;gray&quot;) rios_brasil.plot(ax = base, color = &#39;red&#39;) plt.show() Agora vamos pegar somente o estado do Pará do conjunto de estados e verificar quais rios fazem intersecção com ele. estado_para = estados_do_brasil[estados_do_brasil[&quot;ESTADOS&quot;] == &quot;Pará&quot;] rios_intersect_para = rios_brasil.intersects(estado_para) print(rios_intersect_para.head(5)) ## 0 False ## 1 False ## 2 False ## 3 False ## 4 False ## dtype: bool O resultado é uma lista booleana, desta forma, vamos filtrar o conjunto de dados de rios com este índice, e então verificar quais deles fazem intersecção com o estado do Pará. rios_para = rios_brasil[rios_intersect_para] Com os dados separados, vamos fazer um plot para melhor visualizar o resultado. Neste plot vamos utilizar o matplotlib, para criar vários subplots. import matplotlib.pyplot as plt # Criando figura e os subplots fig, (ax1, ax2) = plt.subplots(ncols=2) base = estados_do_brasil.plot(ax = ax1, color = &#39;blue&#39;) rios_para.plot(ax = base, color = &#39;red&#39;) base = estado_para.plot(ax = ax2, color = &#39;gray&#39;) rios_para.plot(ax = base, color = &#39;red&#39;) plt.show() Veja que esta operação verificou somente aqueles que fazem intersecção com as fronteiras, não indicando que está contido ou próximo ao estado. 3.2.5 Manipulação de projeções Uma operação muito importante quando se está trabalhando dados espaciais é a manipulação de suas projeções, estas que como explicado no capítulo anterior, fazem as representações das geometrias no espaço, o GeoPandas fornece um método muito simples para tal operação, o to_crs, que altera a projeção dos dados sem grandes problemas. Este foi o capítulo sobre GeoPandas e suas facilidades de uso 🌟, não deixe de consultar a documentação oficial e fazer seus testes 💫. "],
["introducao-ao-postgis.html", "4 Introdução ao postgis 🐘 4.1 Instalação 4.2 Um pouco de SQL", " 4 Introdução ao postgis 🐘 Uma das principais características que diferenciam os bancos de dados geográficos dos demais bancos de dados convencionais, é a presença de uma coluna com a finalidade de armazenar uma propriedade geográfica do registro. Além disso , os bancos de dados geográficos também devem oferecer de forma otimizada suporte à operações espaciais. Diferente de um passado não muito distante, atualmente existem muitas alternativas de bancos de dados geográficos, como: SQL Server Spatial, ESRI ArcSDE, Oracle Spatial, GeoMesa, PostGIS, etc. Cada uma destas opções tem o objetivo em comum trabalhar com dados geográficos e todas estão sendo muito utlizadas em diversos segmentos nos dias de hoje, sendo o PostGIS a mais popular de todas. O PostGIS é uma extensão geográfica open source para o SGDB (Sistema Gerenciador de Banco de Dados) PostgreSQL, lançada em 2001 inicialmente por uma empresa canadense chamada Refractions Research. O PostGIS segue a padronização estabelecida pelo OGC (Open GIS Consortium), que provê suporte para todos os objetos e funções da especificação SFS (Simple Features for SQL). De forma concisa, a especificação SFS foi criada pelo OGC (consórcio formado por empresas, universidades, etc) e trata das questões de representação da componente espacial e vetorial dos dados geográficos, garantindo assim, a interoperabilidade entre os sistemas os utilizam. Este capítulo tem como objetivo introduzir ao leitor à extensão espacial PostGIS . Ao final, o leitor deverá está apto a configurar corretamente o ambiente para a utilização da ferramente, carregar arquivos vetoriais e realizar operações espaciais. 4.1 Instalação Como o PostGIS é uma extensão do PostgreSQL, primeiramente deverá ser feita a instalação do SGBD. Importante: Não esqueça o nome de usuário e senha que você definir durante a instalação, pois essas informações serão de suma importância, anote se necessário. A versão do PostgreSQL utilizada aqui é será a 11.5. A instalação do PostgreSQL e PostGIS no sistema operacional windows, pode ser feita através do instalador disponível nesse link, para isso fique atento durante a instalação e na segunda tela do assistente, no item Spatial Extensions marque a opção PostGIS. A instalação do PostgreSQL e PostGIS no sistema Operacional MacOS pode ser feita através do gerenciador de pacotes brew, utilizado os seguintes comandos: brew install postgres brew install postgis Para a instalação nos sistemas operacionais linux, utilize os seguintes comandos : sudo apt install postgresql postgresql-contrib sudo apt-get install postgis Para verificar se a instalação do PostgreSQL foi realizada corretamente, abra o terminal e digite o seguinte comando: psql --version Se tudo ocorreu bem, deverá aparecer uma saída com a versão do PostgreSQL, algo parecido com psql (PostgreSQL) 11.5. Para verificar a instalação do PostGIS, abra o terminal e execute o seguinte comando para abrir o interpretador do PostgreSQL: sudo -u &lt;user&gt; psql Obs: Substitua o trecho &lt;user&gt; para o usuário do PostgreSQL definido na instalação. Com o terminal do PostgreSQL aberto, execute o seguinte comando para verificar a versão do PostGIS: SELECT PostGIS_version(); Se tudo estiver certo, deverá aparecer como saída a versão do PostGIS. Para sair do interpretador psql, basta executar o comando \\q. E com isso finalizamos as configuração iniciais necessárias iniciar os trabalhos com o PostGIS. Para mais informações, consulte a página oficial do PostGIS em: https://postgis.net/install. Na próxima seção iremos criar um banco de dados novo e habilitar nele a extensão espacial PostGIS, para que possam ser executadas as nossas primeiras consultas espaciais. 4.2 Um pouco de SQL SQL (Structured Query Language) é linguagem padrão de consultas declarativas dos bancos de dados relacionais. Ela foi concebida na década de 1970, como resultado de um estudo feito por Edgar Frank Codd, que na época era funcionário da IBM, e propôs o modelo de banco de dados relacional (Codd 1970) que em sua essência é utilizado até os dias de hoje. Como dito anteriormente, o PostGIS é uma extensão espacial que funciona sobre o SGBD PosgreSQL, que utiliza o modelo de banco de dados relacional. Sendo assim, antes de iniciarmos de fato as consultas espaciais como o PostGIS, iremos executar alguns comandos SQL básicos para preparação do ambiente. 4.2.1 Acessando a interface PostgreSQL O psql é uma interface padrão que funciona por linha de comando, e permite interagir rapidamente com o PostgreSQL. Como o foco deste material é a apenas apresentar alguns recursos do PostGIS, iremos executar as consultas SQL usando o psql, o que não é muito recomendado se trabalhar com esquemas mais complexos de bancos de dados, para isso, podem ser utilizado outras interfaces mais agradávies e eficienes como o pgAdmin. Para acessar o psql execute o comando abaixo, substituindo o trecho &lt;user&gt;, pelo nome de usuário postgres que foi definido durante a instalação: sudo -u &lt;user&gt; psql Ao ser solicitado a senha, digite a senha de administrador do seu sistema operacional. O psql possui algumas utilitário para o geraciomento do PostgreSQL, use o comando \\l para listar todos os bancos de dados disponíveis, em sua máquina. Algo parecido com o que mostrado na Figura 4.1 deverá aparecer. Figure 4.1: Listando todos os banco de dados através do psql. Normalmente, a instalação padrão do PostgreSQL cria algumas bases de dados. A seguir, iremos utilizar comandos SQL para criar um novo banco de dados e também adicionar a extensão espacial do PostGIS. 4.2.2 Criando uma nova base de dados A linguagem SQL é organizada em alguns subconjuntos, cada um deles com comando específicos para determinadas tarefas. A Figura 4.2 mostra a os subconjuntos que compõe a linguagem SQL. Figure 4.2: Listando todos os banco de dados através do psql. DDL - Data Definition Laguage (Linguagem de Definição de Dados): É o subconjunto de instruções da linguagem SQL responsável por manipular diretamente o esquema do banco de dados e estrura das tabelas. DML - Data Manipulation Language (Linguagem de Manipulação de Dados): É o subconjunto de instruções da linguagem SQL responsável por interagir diretamente com os dados das tabelas. DCL - Data Control Language (Linguagem de Controle de Dados): É o subconjunto de instruções da linguagem SQL responsável por administrar a segurança das bases de dados, adicionando ou removendo permissões. TCL - Transaction Control Language (Linguagem de Controle de Transação): É o subconjunto de instruções da linguagem SQL responsável por gerenciar as transações das consultas SQL. Neste material, o escopo abordado será apenas alguns comando do subconjunto DDL e DML. Para mais informações a respeito do gerenciamento de banco de dados e a organização da linguagem SQL, recomenda-se a leitura do trabalho de (Kumar, Raheja, and Sachdeva 2012), o qual aborada com mais aprofundamento estes tópicos. Agora iremos criar um banco de dados para trabalharmos com os recursos espacias do PostGIS, para isso execute o comando a seguir: CREATE DATABASE dbgeo; O comando acima cria um novo banco de dados chamado dbgeo. Caso queira o criar um banco de dados com o nome diferente, utilize o mesmo comando substituindo o trecho dbgeo pelo nome desejado. Após receber a mensagem de confirmação, será necessário mudar o interpretador psql para o novo banco de dados criado, para isso utilize o seguinte comando: \\l dbgeo; Note que o trecho dbgeo é o nome da base de dados que foi criada no passo anterior. Se tudo estiver ocorrido bem, deverá aparecer a confirmação conforme a Figura 4.3. Figure 4.3: Criando e alterando base dados. Por fim, para habilitarmos a nova base de dados para suportar operações com dados espaciais, iremos adicionar a extensão PostGIS. Para isso, execute o seguinte comando: CREATE EXTENSION postgis; Após adicionarmos a extensão PostGIS em nosso banco de dados, vamos criar a nossa primeira tabela com atributos geométricos. "],
["references.html", "5 References", " 5 References "]
]
