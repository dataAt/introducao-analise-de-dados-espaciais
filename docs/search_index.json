[
["introducao.html", "1 Introdu√ß√£o üåê 1.1 Representa√ß√µes de dados espaciais 1.2 Sistema de refer√™ncia espacial 1.3 Proje√ß√µes cartogr√°ficas 1.4 Sistema de Coordenadas 1.5 Open Geospatial Consortium (OGC) 1.6 Relacionamentos espaciais nomeados 1.7 Matriz de 9-Interse√ß√µes Estendida dimensionalmente", " 1 Introdu√ß√£o üåê A aplica√ß√£o de dados espaciais no entendimento de um fen√¥meno geogr√°fico data-se muito antes da cria√ß√£o dos computadores como os conhecemos. Um famoso exemplo no estudo de ‚Äúan√°lises espaciais de dados‚Äù foi pioneiro em relacionar vari√°veis estudadas a sua localiza√ß√£o geogr√°fica. Em meados do s√©culo XIX, durante uma das epidemias de c√≥lera na cidade de Londres, John Snow foi bem-sucedido em determinar o epicentro da epidemia. Cruzando a localiza√ß√£o das casas em que ocorreram √≥bitos por c√≥lera com pontos de abastecimentos de √°gua para consumo humano da cidade, John Snow foi capaz de determinar a forma de transmiss√£o da doen√ßa e identificar a bomba de √°gua localizada em ‚Äúbroad-street‚Äù como cr√≠tica (Figura 1.1). Figure 1.1: Mapa de Londres com √≥bitos por c√≥lera (pontos) e po√ßos de √°gua (cruzetas) Como abordado anteriormente, o uso de dados espaciais abrangem diversas aplica√ß√µes, tais como: estudo de concentra√ß√£o espacial na distribui√ß√£o de roubos, an√°lise de regi√µes para fins de zoneamento agr√≠cola e estimativa da extens√£o de um dep√≥sito mineral em uma regi√£o a partir de amostras (Monteiro et al. 2004). Desta forma, sempre que onde aparece no problema a ser estudado, usa-se recursos computacionais e ferramentas voltadas para an√°lise de dados espaciais. A Figura 1.2 apresenta alguns equipamentos de coleta de dados espaciais, como sat√©lite, radar e VANT (Ve√≠culo a√©reo n√£o tripulado). Figure 1.2: Fontes de dados espaciais - Fonte: (waypoint 2015) Com o avan√ßo do potencial computacional e subsequente desenvolvimento dos SIG (Sistemas de Informa√ß√£o geogr√°ficas) permitiu-se um maior desenvolvimento de estudos voltados √† fen√¥menos geogr√°ficos, reduzindo assim custos e facilitando a manipula√ß√£o de dados espaciais. Ainda que com uma defasagem temporal, no Brasil esta √°rea seguiu em forte desenvolvimento, e apresenta-se hoje aplicada tanto no meio corporativo quanto no meio acad√™mico. Em rela√ß√£o √†s produ√ß√µes acad√™micas podemos citar trabalhos realizados no INPE (Instituto Nacional de Pesquisas espaciais), apresentando qualidade Internacional com publica√ß√µes em revistas altamente conceituadas. Tomando como exemplo trabalhos desenvolvidos atualmente no curso de p√≥s-gradua√ß√£o em sensoriamento remoto do INPE, podemos visualizar a gama de utiliza√ß√£o de dados espaciais para o entendimento dos mais diversos fen√¥menos. Estes estudos v√£o desde aplica√ß√µes em macro escala como o monitoramento da Amaz√¥nia brasileira, em fun√ß√£o do desmatamento, das queimadas e a deteriora√ß√£o dos recursos h√≠dricos, bem como em escalas mais finas como estudos em reservat√≥rios, √°reas urbanas e de luzes noturnas. A Se√ß√£o Para saber mais apresenta alguns estudos desenvolvidos no INPE. O objetivo deste minicurso √© apresentar de forma simples e objetiva os conceitos fundamentais de dados espaciais, bem como m√©todos para analis√°-los. Sinta-se √† vontade para contribuir com este material, esperamos que goste deste pequeno material produzido! üë©‚Äçüî¨ 1.1 Representa√ß√µes de dados espaciais Dentro do universo estrutural dos SIGs (Sistema de Informa√ß√£o Geogr√°ficas), a forma de representa√ß√£o dos dados geogr√°ficos podem ser divididas em duas grandes classes: vetoriais e matriciais. Sendo que as estruturas de dados vetoriais s√£o representa√ß√µes que denotam as fronteiras de entidades geogr√°ficas, ou seja, atrav√©s de suas caracter√≠sticas √© poss√≠vel descrever computacionalmente as formas de uma superf√≠cie. J√° a classe matricial, representa informa√ß√µes estruturadas em forma de matriz (linhas e colunas). Cada elemento dessa matriz √© formado por um determinado valor associado a sua localiza√ß√£o e formalmente pode ser representado como uma matriz P(m,n) composto de m colunas e n linhas. Contudo a representa√ß√£o dos dados espaciais √© composto por uma gama de grupos pertencentes √†s representa√ß√µes vetoriais e matriciais, de tal forma que cada grupo deve ser explorado e suas particularidades aprofundadas separadamente. 1.1.1 Vetoriais A estrutura de dados espaciais no formato vetorial √© utilizada para representar a fronteira de uma entidade geogr√°fica, sendo que suas coordenadas espaciais s√£o os pontos que descrevem a posi√ß√£o e dire√ß√£o de um objeto. Para a classe de estruturas vetoriais suas entidades b√°sicas (Figura 1.3) s√£o representadas nas formas de pontos, linhas e pol√≠gonos. Figure 1.3: Representa√ß√£o no plano unidimensional das formas vetoriais. Um ponto tem como finalidade a identifica√ß√£o ou localiza√ß√£o de uma ocorr√™ncia no espa√ßo, onde um par ordenado (x,y) de coordenadas √© utilizado para identificar sua posi√ß√£o geogr√°fica, um dos exemplos para representa√ß√£o de pontos pode ser exemplificado como a localiza√ß√£o do ponto central de uma cidade ou localidade. Uma linha √© composta por um conjunto de pontos e representa uma estrutura unidimensional no espa√ßo, √© bastante utilizada para representa√ß√£o de rios e estradas. Um pol√≠gono ‚Äú√© a regi√£o do plano limitada por uma ou mais linhas poligonais conectadas de tal forma que o √∫ltimo ponto de uma linha seja id√™ntico ao primeiro da pr√≥xima‚Äù Casanova et al. (2005). 1.1.2 Matriciais Diferente das representa√ß√µes vetoriais, onde cada fen√¥meno √© apresentado como um objeto espacial, nas estruturas matriciais (raster) os atributos presentes nos fen√¥menos est√£o associados a elementos em uma matriz. Cada valor armazenado na estrutura matricial t√™m suas caracter√≠sticas relacionadas a uma posi√ß√£o, essa posi√ß√£o tamb√©m √© chamada de c√©lula, e √© respons√°vel por armazenar um valores que representam uma √°rea espec√≠fica da superf√≠cie. Uma das caracter√≠sticas presentes nas estruturas matriciais √© a resolu√ß√£o espacial que corresponde a um valor relacionado a dimensionalidade linear em um espa√ßo geogr√°fico. ‚ÄúQuanto menor a dimens√£o das c√©lulas, maior a resolu√ß√£o da imagem matricial e, consequente, maior a quantidade de mem√≥ria necess√°ria para armazen√°-la‚Äù Lisboa Filho and IOCHPE (2001). Figure 1.4: Estrutura para representa√ß√£o matricial onde cada c√©lula tem um valor de atributo (UM ou ZERO) A representa√ß√£o matricial pressup√µe que o espa√ßo amostral dos elementos que comp√µem uma superf√≠cie plana tenham um valor de atributo associado, ou seja, cada c√©lula est√° cont√©m um valor e uma localiza√ß√£o (linha e coluna) da matriz. Al√©m da representa√ß√£o simples, √© poss√≠vel generalizar que os espa√ßos celulares podem estar associados a mais de um atributo, ou seja, uma quantidade maior de fen√¥menos est√° associada a uma localiza√ß√£o da matriz, essa associa√ß√£o pode ser do tipo espa√ßo-temporal para retratar fen√¥menos dentro de uma s√©rie temporal, esta forma de representa√ß√£o √© muito conveniente para armazenar os dados no formato de bancos de dados do tipo objeto-rela√ß√£o. 1.2 Sistema de refer√™ncia espacial Bem, como vimos at√© aqui, dados espaciais possuem duas caracter√≠sticas fundamentais, o registro de diferentes fen√¥menos e sua localiza√ß√£o. Mas como esta localiza√ß√£o √© vinculada a uma posi√ß√£o da superf√≠cie terrestre? Para conseguirmos responder a esta pergunta devemos ir por partes. Vamos come√ßar imaginando uma superf√≠cie plana, como a apresentada abaixo. Agora perceba que, para gerar tal superf√≠cie o que precisou ser feito foi delimitar quatro pontos e ent√£o ligar cada um deles, veja. At√© aqui apenas criamos uma superf√≠cie e delimitamos seu espa√ßo atrav√©s dos pontos ABCD, vamos agora inserir valores para os lados desta superf√≠cie. Lembre-se que, est√° superf√≠cie representa um quadrado, e assim, todos os seus lados t√™m o mesmo tamanho. Certo! Com os limites definidos podemos agora adicionar um ponto nesta superf√≠cie, isto porque, se cada um dos lados vai de 0 a 10, conseguimos facilmente inserir um ponto utilizando os lados como refer√™ncia. Ok, mas, o que √© isso tem a ver com sistemas de refer√™ncia espacial e nossa pergunta inicial? Tudo! Isto j√° que, para sabermos onde estava o ponto e sua localiza√ß√£o precisamos definir os limites da superf√≠cie, e a mesma situa√ß√£o √© necess√°ria para os dados espaciais e a superf√≠cie terrestre. Ent√£o, com a mesma l√≥gica aplicada a superf√≠cie quadrada do exemplo anterior podemos mapear todo o planeta Terra, por√©m alguns problemas surgem para este caso. Primeiro, para come√ßarmos a mapear a superf√≠cie terrestre devemos entender: Como √© a superf√≠cie terrestre; e formas de representa√ß√£o. Come√ßando com a superf√≠cie terrestre, as ci√™ncias geod√©sicas, que se empenham em realizar os estudos das formas e dimens√µes da Terra dividem sua superf√≠cie em tr√™s formas diferentes (Montanari 2014). Na Figura acima o ge√≥ide representa tudo que est√° no n√≠vel do mar, o elipsoide representa a camada abaixo do ge√≥ide e o terreno a parte superior ao ge√≥ide, al√©m disto, tanto a representa√ß√£o da superf√≠cie terrestre quanto o ge√≥ide carregam diversas dificuldades quando precisam ser representados, por conta de suas caracter√≠sticas irregulares, por isto, adota-se como representa√ß√£o da superf√≠cie, o elipsoide. Com isto, pode-se concluir que, o ge√≥ide √© a superf√≠cie de medi√ß√£o da Terra, enquanto o elipsoide √© a superf√≠cie de representa√ß√£o. Certo, com a defini√ß√£o da forma de representa√ß√£o da superf√≠cie terrestre j√° podemos realizar todo o mapeamento, correto? Ainda n√£o, pois al√©m de entendermos como √© a superf√≠cie precisamos definir como toda esta superf√≠cie terrestre ser√° representada. Tal representa√ß√£o pode ser feita de diversas formas, a variar de acordo com a necessidade, algumas dessas formas s√£o apresentadas na Figura abaixo. Onde, a superf√≠cie esf√©rica normalmente √© utilizada como representa√ß√£o da Terra quando h√° grandes quantidades de √°rea a serem representadas, como por exemplo, diversos continentes ou mesmo o planeta todo (Montanari 2014) . J√° para os casos, onde √© necess√°rio a representa√ß√£o de uma quantidade de Terra consider√°vel, por√©m, n√£o t√£o grande como o planeta todo, utiliza-se a representa√ß√£o elips√≥idica (Montanari 2014), esta que inclusive √© a mais utilizada nas aplica√ß√µes espaciais atuais. Por fim, tem-se o modelo geoidal, que como j√° citado, √© o que mais se aproxima da superf√≠cie terrestre, por√©m sua representa√ß√£o pode ser muito complexa para o mapeamento da superf√≠cie terrestre e a gera√ß√£o das localiza√ß√µes. Beleza! Agora entendemos todo o fluxo necess√°rio para realizar do mapeamento, partindo da defini√ß√£o da superf√≠cie e indo at√© suas formas de representa√ß√£o. Com isto, conseguimos fazer uma defini√ß√£o de sistemas de refer√™ncia espacial que seja clara e concisa. Sistemas de refer√™ncia espacial, ou DATUM, √© um sistema coordenado, utilizado para representar caracter√≠sticas f√≠sicas e geom√©tricas do planeta Terra. Alguns exemplos de sistemas de refer√™ncia espacial s√£o: WGS 84; Sirgas 2000. Muito interessante, por√©m, mesmo com este entendimento ficou uma d√∫vida, como √© que os pontos v√£o ser representados, da mesma forma que hav√≠amos feito no exemplo? Bem, esta pergunta √© respondida nas se√ß√µes seguintes. 1.3 Proje√ß√µes cartogr√°ficas At√© esta se√ß√£o, todas as informa√ß√µes passadas de representa√ß√µes da superf√≠cie terrestre utilizaram modelos tridimensionais para tal feito, por√©m, se estas representa√ß√µes possuem tr√™s dimens√µes, como mapas bidimensionais, com o apresentado abaixo s√£o gerados? A resposta √© simples! Proje√ß√µes cartogr√°ficas, estas que atrav√©s de transforma√ß√µes geom√©tricas realizam a convers√£o das representa√ß√µes tridimensionais para bidimensionais, mantendo a correspond√™ncia entre ambas IBGE (2016a). 1.3.1 Tipos de proje√ß√£o Por se tratar de opera√ß√µes geom√©tricas √© esperado que nessas existam distor√ß√µes (IBGE 2016a), por conta disto existem diferentes tipos de superf√≠cies geom√©tricas de proje√ß√£o que s√£o utilizadas (IBGE 2016b), para que as superf√≠cies no momento da proje√ß√£o foram a menor quantidade poss√≠vel de distor√ß√µes nas √°reas de interesse. As subse√ß√µes a seguir apresentam alguns tipos de superf√≠cies geom√©tricas utilizadas para as proje√ß√µes. 1.3.1.1 Proje√ß√£o cil√≠ndrica Na proje√ß√£o cil√≠ndrica o esferoide de representa√ß√£o da Terra √© envolvido sobre um cilindro tangente. Neste tipo de proje√ß√£o h√° muitas distor√ß√µes dos polos, sul e norte, o que faz com que estes pare√ßam ter tamanhos bem maiores do que deveriam. 1.3.1.2 Proje√ß√£o C√¥nica As proje√ß√µes c√¥nicas s√£o geradas atrav√©s da utiliza√ß√£o de um cone, que favorece a redu√ß√£o de distor√ß√µes nos meridianos e aumenta a distor√ß√£o nos polos. 1.3.1.3 Proje√ß√£o plana Proje√ß√£o que √© gerada com base em um plano, que toca em um ponto espec√≠fico da representa√ß√£o da esfera terrestre. Como √© poss√≠vel perceber na Figura acima, neste tipo de proje√ß√£o √© esperado que haja muitas distor√ß√µes no entorno do ponto utilizado como refer√™ncia para sua cria√ß√£o. 1.4 Sistema de Coordenadas Bem, mesmo com as v√°rias formas de representa√ß√£o e proje√ß√£o, √© mais que necess√°rio utilizamos de alguma t√©cnica que nos permita, dentro de cada uma das representa√ß√µes, apontar sem nenhum tipo de ambiguidade as posi√ß√µes nas quais diferentes objetos est√£o na superf√≠cie terrestre. 1.4.1 Sistemas de Coordenadas Geogr√°ficas Ent√£o, para que cada objeto na superf√≠cie da Terra fosse facilmente identificado, sem nenhum tipo de ambiguidade, um sistema de linhas imagin√°rias, nomeado de Sistemas de Coordenadas Geogr√°ficas foi criado. Neste sistema existem dois tipos de linhas, os meridianos e os paralelos. Para os meridianos tem-se que s√£o linhas imagin√°rias que cortam a Terra no sentido norte-sul e para os paralelos, tem-se linhas que circulam a Terra no sentido leste-oeste (IBGE 2016b). Vale acrescentar tamb√©m que, os paralelos nos representam as latitudes, que s√£o a dist√¢ncia em graus da linha do Equador at√© um determinado paralelo. Os valores da latitude podem variar de 0¬∞ (Sob a linha do Equador) a 90¬∞ (Sob as extremidades), sendo que, para os hemisf√©rios norte s√£o considerados valores positivos e para o hemisf√©rio sul valores negativos. J√° as longitudes representam a dist√¢ncia, em graus, entre o meridiano de Greenwich at√© um outro meridiano qualquer. Seus valores variam de 0¬∞ (Sob o meridiano de Greenwich) a 180¬∞ (Nas extremidades leste e oeste a Greenwich), onde, para o leste consideram-se valores positivos e ao oeste valores negativos (IBGE 2016b). A representa√ß√£o de todo este sistema imagin√°rio de linhas pode ser visto na Figura abaixo. 1.4.2 Coordenadas planas Outra forma de realizar o mapeamento das posi√ß√µes das representa√ß√µes das superf√≠cies terrestres √© feita com o m√©todo nomeado de Coordenadas planas, que de acordo com Santos, Barbosa, and Gomes (2016) s√£o recomendados para atividades de medi√ß√µes de √°reas e dist√¢ncias. O sistema de coordenadas planas √© baseado no sistema cartesiano de representa√ß√£o, onde em um plano bidimensional o cruzamento de duas linhas faz a representa√ß√£o da localiza√ß√£o de um ponto (Santos, Barbosa, and Gomes 2016), sendo que o eixo X representa a Latitude e o eixo Y a longitude. Espere um pouco, representa√ß√£o em um plano? At√© aqui vimos a representa√ß√£o geogr√°fica que √© feita sobre a representa√ß√£o esferoidal da superf√≠cie terrestre e s√≥ vimos a superf√≠cie plana nas proje√ß√µes. Pois bem, para a utiliza√ß√£o do sistema de coordenadas planas √© assumido que alguma proje√ß√£o seja aplicada, normalmente utiliza-se a superf√≠cie c√¥nica na proje√ß√£o dos dados para a utiliza√ß√£o deste sistema (Santos, Barbosa, and Gomes 2016). Lembra do mercator que citamos anteriormente, a forma de representa√ß√£o para coordenadas planas comumente utilizada tamb√©m √© dele, e possui o nome de Sistema Universal Transversa de Mercator. 1.4.3 C√≥digos EPSG Os c√≥digos European Petrolem Survey Group (EPSG) representam uma forma de organiza√ß√£o dos mais diversos sistemas de refer√™ncias e seus sistemas de coordenadas, desta forma os c√≥digos EPSG criam uma forma r√°pida e simples para a busca e identifica√ß√£o de qual sistema de refer√™ncia e sistema de coordenadas est√° sendo utilizado. Como estes c√≥digos abrangem todos os sistemas de coordenadas do mundo, com os mais variados sistemas de coordenadas, abaixo √© apresentado uma tabela com somente alguns dos c√≥digos EPSG mais utilizados no Brasil. C√ìDIGO EPSG PROJE√á√ÉO/DATUM 4225 GCS 4618 Corrego Alegre 4674 GCS SAD69 4326 GCS SIRGAS 22521 2000 22522 GCS WGS84 22523 Corrego 1.5 Open Geospatial Consortium (OGC) A organiza√ß√£o Open Geospatial Consortium (Cons√≥rcio Geoespacial Aberto, OGC) √© respons√°vel por reunir organiza√ß√µes volunt√°rias que trabalham no desenvolvimento e implementa√ß√£o de padr√µes geom√©tricos para o processamento de dados em um SIG. O OGC prop√µem dentro de suas normas que para dados espaciais existem dois tipos a serem descritos na sua forma simples, geometry (geometria) e geography (geografia) que oferecem suporte a outros dezesseis objetos (ou inst√¢ncias) derivados, por√©m apenas onze podem ser instanciados diretamente. Os modelos de objetos geom√©tricos do OGC possuem caracter√≠sticas que podem ser descritas dentro do seu conjunto de normas e implementa√ß√µes, essas caracter√≠sticas fazem parte da arquitetura que descreve objetos comuns chamado Simple Features. Para descrever a hierarquia geometry onde os tipos de dados s√£o baseados, √© poss√≠vel criar inst√¢ncias que representam os tipos de dados geogr√°ficos, para isso a figura ilustra os principais tipos de dados para geometry e geography. Figure 1.5: Principais tipos geom√©tricos (OGC) - Fonte: (Egenhofer and Franzosa 1991) Os tipos de dados espaciais dentro do OGC Simple Features (Figura 1.5) est√£o divididos em dezesseis tipos de diferentes inst√¢ncias, podendo ser divididos em outros tr√™s grupos: Primitivos, M√∫ltiplos e Cole√ß√µes. No tipo primitivo temos os seguintes objetos: Ponto (POINT): Um ponto √© um objeto 0-dimensional que representa uma localiza√ß√£o simples para coordenadas espaciais, sendo composto por um par ordenado de coordenadas (x,y) associados a um sistema de refer√™ncias espaciais. Linha (LINESTRING): √â composto por um conjunto de pontos interpolados linearmente onde cada par consecutivo de pontos define um segmento de linha, ou seja um LINESTRING √© exatamente a interpola√ß√£o entre dois pontos ou um conjunto de pontos. Pol√≠gono (POLYGON): O pol√≠gono √© definido como uma superf√≠cie planar com fronteira exterior e zero ou mais superf√≠cies interiores. Para compor um pol√≠gono √© necess√°rio que um conjunto de 3 ou mais pontos distintos para formar os v√©rtices do mesmo. J√° para o grupo dos M√∫ltiplos, os tipos de dados relacionados s√£o baseados na cole√ß√£o dos tipos simples, ou seja, para um MULTIPOINT basta que um conjunto de pontos esteja associado com zero o mais inst√¢ncias; J√° para MULTILINESTRING o mesmo √© aplicado, sendo que o conceito de MULTICURVE m√∫ltiplas curvas entre pontos √© o que define a cole√ß√£o de objetos associados, al√©m disso o MultiLineString pode ser do tipo simples, fechada ou n√£o fechada; J√° o MULTIPOLYGON pode ser definido como parte de uma superf√≠cie bi-dimensional dentro do GeomCollection, onde os elementos s√£o formados por um conjunto de pol√≠gonos adjacentes. Figure 1.6: Hierarquia da OGC Simple Feature simplificada Existe uma diferen√ßa significativa para os tipos de dados de geometry e geography, os dois se comportam de maneira semelhante por√©m algumas diferen√ßas importantes devem ser levadas em considera√ß√£o. Existem tipos de medidas para dados espaciais, dentre estes tipos de medidas podemos destacar as medidas de sistema planar (terra plana) e os sistemas elipsoidal (terra redonda), onde as medidas de dist√¢ncia e √°reas possuem varia√ß√µes que devem ser levadas em considera√ß√£o para obten√ß√£o de medidas mais precisas. Assim como as medidas para os dados espaciais √© importante determinar a orienta√ß√£o dos dados espaciais, em sistemas planares a orienta√ß√£o do anel do pol√≠gono n√£o √© um fator importante, j√° para sistemas elipsoidais um pol√≠gono pode ter valores amb√≠guos caso a sua orienta√ß√£o n√£o seja definida. 1.6 Relacionamentos espaciais nomeados Realizar a caracteriza√ß√£o do relacionamento entre os objetos espaciais permite a cria√ß√£o de contextos sem√¢nticos sobre estes (C√¢mara et al. 2005) e assim seja poss√≠vel a extra√ß√£o de informa√ß√µes relevantes (Ferreira 2010). √â tido que, existem alguns tipos de relacionamentos entre os objetos que podem ser utilizados para tal caracteriza√ß√£o, sendo eles, topol√≥gicos, m√©tricos e de ordem (C√¢mara et al. 2005). Os relacionamentos m√©tricos representam rela√ß√µes que tratam especificamente de √°rea de dist√¢ncia entre objetos. J√° os de ordem representam a forma com que um objeto est√° disposto ao outro. Os topogr√°ficos consideram os relacionamentos de interse√ß√£o entre os objetos. Todos os tipos citados anteriormente ser√£o tratados em algum momento durante esta documenta√ß√£o, por√©m nesta se√ß√£o as rela√ß√µes topogr√°ficas ter√£o uma enfase especial, isto j√° que, diferente das demais, apresenta uma estrutura pr√≥pria para seus relacionamentos e ainda, segundo Bogorny and Iochpe (2001), representa a forma de rela√ß√£o espacial mais utilizada, j√° que esta faz analogias diretas a como percebemos a espacialidade do mundo real. Desta forma, as subse√ß√µes abaixo apresentam um pouco mais sobre os relacionamentos topogr√°ficos, tamb√©m denominados de relacionamentos espaciais nomeados, uma vez que, possuem uma defini√ß√£o formal, que vai desde sua nomenclatura at√© as formas de representa√ß√£o. 1.6.1 Relacionamentos espaciais Esta subse√ß√£o busca de forma simples, apresentar a defini√ß√£o formal dos relacionamentos espaciais nomeados. Em um segundo momento, na documenta√ß√£o do Python, R e PostGIS deste material h√° exemplos de aplica√ß√µes de tais relacionamentos. Para o entendimento destes relacionamentos, vamos come√ßar fazendo a defini√ß√£o das regi√µes das geometrias, assunto base para o entendimento das formas de rela√ß√£o, para isto, veja a Figura abaixo. Perceba que, para cada uma das principais geometrias h√° um conjunto de tr√™s defini√ß√µes. O interior refere-se diretamente a √°rea interna da geometria, enquanto que a fronteira representa somente o contorno da √°rea e o exterior sendo toda √°rea que n√£o √© preenchida pela geometria. Certo, vejamos agora, alguns tipos de relacionamentos espaciais: contains - Verifica se a geom√©tria B cont√™m A; equal - Verifica se duas geom√©trias s√£o iguais. Por√©m, somente ao ler a descri√ß√£o de cada um dos m√©todos de relacionamentos apresentados acima √© poss√≠vel perceber um problema. O que significa dizer que a geometria B cont√©m A ? Ou mesmo, o que torna as geometrias iguais ? Por conta destas quest√µes que cada um destes m√©todos possui uma defini√ß√£o formal, que como citado anteriormente, evita qualquer tipo de m√∫ltiplas interpreta√ß√µes, mas como esta defini√ß√£o pode ser feita ? Para este problema Bogorny and Iochpe (2001) indica que diversas abordagens podem ser aplicadas, por√©m √© comum a aplica√ß√£o de matrizes de interse√ß√£o, descrevendo o comportamento de cada regi√£o da geometria nos m√©todos de relacionamento. C√¢mara et al. (2005) define que para casos simples pode ser utilizada a chamada Matriz de 4-Interse√ß√µes, que define 8 rela√ß√µes espaciais nomeadas e descreve o que cada uma dessas opera√ß√µes leva em considera√ß√£o. A Matriz de opera√ß√µes √© apresentada abaixo. Figure 1.7: Matriz 4-Interse√ß√µes Fronteira (‚àÇ); interior (¬∞); exterior (-); vazio (‚àÖ); n√£o vazio (¬¨‚àÖ) - Fonte: EGENHOFER, DI FELICE, and CLEMENTINI (1994) O ponto importante da Figura apresentada acima √© que, para cada um dos m√©todos que est√£o sendo apresentados, h√° exatamente o que ele considera, por exemplo, vejamos o m√©todo contains, que indica se uma geometria est√° ou n√£o contida em outra. Neste m√©todo existem quatro cen√°rios poss√≠veis. No primeiro, √© considerado se as fronteiras (‚àÇ) est√£o se cruzando, e caso estejam n√£o √© considerado que uma cont√©m a outra. O segundo caso verifica se o interior (¬∞) de uma geometria est√° em outro, e caso esteja √© considerado que uma est√° contida em outra. Veja que interessante! Atrav√©s de uma defini√ß√£o simples e direta j√° foi poss√≠vel perceber os poss√≠veis casos de cada m√©todo. H√° casos em que a Matriz de 4-Interse√ß√µes n√£o √© o suficiente para fazer as representa√ß√µes (C√¢mara et al. 2005), para estes casos outros modelos podem ser utilizados, como √© o caso da Matriz de 9-Interse√ß√µes Dimensionalmente estendidas, apresentada na se√ß√£o seguinte a esta. 1.6.2 Restri√ß√µes espaciais Em certos casos, o fen√¥meno que est√° sendo representado pelos dados espaciais faz com que sejam necess√°rios a aplica√ß√£o de regras e restri√ß√µes espec√≠ficas sobre os mesmos (Bogorny and Iochpe 2001). Esta regra tamb√©m √© aplic√°vel no contexto dos relacionamentos espaciais. Por exemplo, o m√©todo disjoint pode ser aplicado considerando qualquer par de geometrias, enquanto que o m√©todo overleap s√≥ pode ser aplicado a pares do mesmo tipo, como por exemplo geometrias de linhas com outras linhas (C√¢mara et al. 2005). Caso voc√™ fique interessado e deseja uma descri√ß√£o completa de todas estas restri√ß√µes, n√£o deixe de consultar o material de Banco de dados geogr√°ficos, disponibilizado pelo INPE. 1.7 Matriz de 9-Interse√ß√µes Estendida dimensionalmente O modelo de novo intersec√ß√µes dimensionalmente estendido (DE9IM) tem como objetivo apresentar um m√©todo para os relacionamentos topol√≥gicos entre objetos geom√©tricos, este modelo considera o resultado da interse√ß√£o entre as fronteiras, interiores e exteriores de duas geometrias (QUEIROZ and C√ÇMARA 2005). A DE9IM √© uma extens√£o da matriz de 4-interse√ß√µes onde oito rela√ß√µes topol√≥gicas bin√°rias s√£o consideradas, estas opera√ß√µes representam a interse√ß√£o entre as fronteiras e o interior de duas geometrias (Egenhofer and Herring 1990). A defini√ß√£o dos relacionamentos topol√≥gicos para a DE9IM visa cobrir as opera√ß√µes entre objetos mais complexos, por exemplo, opera√ß√µes entre ilhas e separa√ß√µes. Para isso se faz necess√°rio estender a matriz de 4-Interse√ß√µes e levar em considera√ß√£o o exterior das geometrias. Para este novo modelo, o resultado da interse√ß√£o entre as fronteiras, interiores e exteriores s√£o avaliados e os valores de opera√ß√µes vazias ou n√£o-vazias tamb√©m √© considerado, pois em alguns casos √© necess√°rio considerar as dimens√µes de interse√ß√µes n√£o vazias, no modelo da Figura x, s√£o consideradas opera√ß√µes entre (Interior, Fronteira e Exterior) de dois objetos A e B onde o resultado das opera√ß√µes contempla um conjunto de 52 relacionamentos topol√≥gicos entre os objetos, sendo que que tais relacionamentos podem ser agrupados em cinco opera√ß√µes mais gerais: touch (toca), in (dentro), cross (cruza), overlap (sobrep√µem) e disjoint (disjunto). Figure 1.8: Matriz de 9-Interse√ß√µes relacionando duas regi√µes entre objetos - Fonte: (Egenhofer and Franzosa 1991) "],
["r.html", "2 R üíé 2.1 Tibble 2.2 SF", " 2 R üíé R √© uma linguagem de programa√ß√£o de alto n√≠vel voltada para visualiza√ß√£o e an√°lise de dados. Com base na linguagem de programa√ß√£o S foi criada pelos estat√≠sticos Ross Ihaka e Robert Gentleman no departamento de estat√≠stica da universidade de Auckland na Nova Zel√¢ndia. A linguagem R √© mantida pelo grupo R Core Team. O artigo publicado pela Tippmann (2015), mostra a crescente ades√£o do uso da linguagem R em diferentes √°reas cientificas. A Figura 2.1 evid√™ncia o crescimento mencionado anteriomente. Figure 2.1: S√©rie temporal de cita√ß√µes dos pacotes feitos em R - Fonte: Tippmann (2015) Como apresentado no cap√≠tulo anterior, o objetivo desta se√ß√£o √© apresentar o uso da linguagem de programa√ß√£o R para an√°lise de dados espaciais, os quais comp√µem a ci√™ncia da geoinforma√ß√£o. 2.1 Tibble As estruturas de dados (ED‚Äôs) do pacote base do R, por exemplo, data.frame e matrix, oferecem diversos m√©todos de adi√ß√£o, manipula√ß√£o e exclus√£o de dados. No entanto, tais m√©todos possuem certas limita√ß√µes impostas pela linguagem, para adicionar quaisquer mudan√ßas nestes m√©todos √© necess√°rio editar o c√≥digo-fonte dos mesmos. Com o objetivo de abstrair as complexidades e o alta verbosidade das estruturas de dados tradicionais, a comunidade cria diversos pacotes que buscam a integra√ß√£o e a f√°cil manipula√ß√£o dos mesmos. Neste minicurso, optamos por usar o pacote tibble do que o m√©todo data.frame oferecido pelo pacote base. No entanto, vamos usar o termo Data frame como estruta de dados, a qual √© implementada pelo pacote tibble. Figure 2.2: Estrutura de dados: Vetor e Matriz Podemos definir Data frame como uma matriz (Figura 2.2), composta por linhas e colunas, cujas colunas representam as vari√°veis (atributos) e as linhas representam observa√ß√µes. A Figura 2.3 apresenta um Data frame, a qual √© poss√≠vel observar as defini√ß√µes mencionadas anteriormente, desta forma, sabemos que o aluno Jos√© obteve 7.2 na disciplina de √Ålgebra Linear. Figure 2.3: Representa√ß√£o de um Data frame - Fonte: GeeksforGeeks (2018) O trecho de c√≥digo a seguir apresenta a implementa√ß√£o do Data frame apresentado anteriomente. # Importa√ß√£o do pacote library(tibble) # Cria√ß√£o do tibble df_escola &lt;- tibble::tibble(Aluno = c(&quot;Jos√©&quot;, &quot;Maria&quot;, &quot;Ana&quot;, &quot;Carlos&quot;), `√Ålgebra Linear` = c(7, 10, 8, 7), `C√°lculo I` = c(8, 9, 10, 5), `Eng. Software` = c(10, 9, 5, 9), `PAD` = c(5, 7, 4, 9)) # Visualiza√ß√£o dos dados df_escola ## # A tibble: 4 x 5 ## Aluno `√Ålgebra Linear` `C√°lculo I` `Eng. Software` PAD ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Jos√© 7 8 10 5 ## 2 Maria 10 9 9 7 ## 3 Ana 8 10 5 4 ## 4 Carlos 7 5 9 9 O pacote tibble possui diversas vantagens em rela√ß√£o ao tradicional data.frame, por exemplo, ainda no tibble criado anteriormente, √© poss√≠vel observar os tipos de cada atributo. Com o objetivo de facilitar a etapa de an√°lise de dados, o pacote tibble n√£o faz a convers√£o de atributos do tipo character para factor de forma autom√°tica. Outra grande vantagem do tibble √© a intera√ß√£o com os m√©todos criados para o data.frame, esses provindos do pacote base, por exemplo, o m√©todo mean(): mean(df_escola$`C√°lculo I`) ## [1] 8 Desta forma, podemos usar quaisquer m√©todos criados para uso no data.frame no tibble. O c√≥digo a seguir mostra que o tibble criado possui tr√™s classes: tbl_df, tbl e data.frame. √â poss√≠vel observar que o tibble possui como classe comum o data.frame. class(df_escola) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Na subse√ß√£o subsequente, vamos explicar com detalhes como realizar a leitura, escrita e manipula√ß√£o de dados. 2.1.1 Tidyverse Com o intuito de desenvolver um conjunto de ferramentas para realizar a leitura, escrita, manipula√ß√£o e visualiza√ß√£o de dados, o estat√≠stico Wickham (2017) e seus colaboradores criaram o Tidyverse, o qual √© apresentado na Figura abaixo ao lado esquerdo. Ao lado direito, √© apresentado as etapas de um projeto de ci√™ncia de dados com aplica√ß√£o no mundo real Schutt and O≈Éeil (2013). Figure 2.4: Conjunto de pacotes do kit de ferramentas e etapas de um projeto de ci√™ncia de dados Neste minicurso, vamos usar os pacotes readr, tibble, dplyr, magrittr e ggplot2. O pacote readr √© utilizado para fazer leitura e escrita de dados. As pr√≥ximas subse√ß√µes descrevem com detalhes os pacotes citados. 2.1.1.1 Leitura e escrita de dados No minicurso de Introdu√ß√£o √† an√°lise de dados, explicamos com detalhes a diferen√ßa entre cada formato de dados e suas respectivas aplica√ß√µes. Nesta subse√ß√£o, vamos criar um conjunto de dados, da seguinte forma: # Cria√ß√£o do tibble df_solo &lt;- tibble::tibble(label = c(&quot;Soja&quot;, &quot;Milho&quot;, &quot;Pastagem&quot;, &quot;Vegeta√ß√£o&quot;), plant_agri = c(TRUE, TRUE, FALSE, FALSE), plat_col = c(&quot;2019-09-01&quot;, &quot;2019-01-10&quot;, &quot;NA&quot;, &quot;NA&quot;)) # Visualiza√ß√£o das observa√ß√µes iniciais do conjunto de dados head(df_solo, 2) ## # A tibble: 2 x 3 ## label plant_agri plat_col ## &lt;chr&gt; &lt;lgl&gt; &lt;chr&gt; ## 1 Soja TRUE 2019-09-01 ## 2 Milho TRUE 2019-01-10 Podemos salvar os dados em diferentes formatos, sendo eles tabulares ou n√£o. Para salvar os dados no formato json, pode ser feito desta forma: # Importa√ß√£o do pacote library(jsonlite) ## Loading required package: methods # Transformando o tibble em json df_solo_json &lt;- jsonlite::toJSON(df_solo, pretty = TRUE) # Visualiza√ß√£o do json df_solo_json ## [ ## { ## &quot;label&quot;: &quot;Soja&quot;, ## &quot;plant_agri&quot;: true, ## &quot;plat_col&quot;: &quot;2019-09-01&quot; ## }, ## { ## &quot;label&quot;: &quot;Milho&quot;, ## &quot;plant_agri&quot;: true, ## &quot;plat_col&quot;: &quot;2019-01-10&quot; ## }, ## { ## &quot;label&quot;: &quot;Pastagem&quot;, ## &quot;plant_agri&quot;: false, ## &quot;plat_col&quot;: &quot;NA&quot; ## }, ## { ## &quot;label&quot;: &quot;Vegeta√ß√£o&quot;, ## &quot;plant_agri&quot;: false, ## &quot;plat_col&quot;: &quot;NA&quot; ## } ## ] Agora que o nosso dado est√° em json, podemos salv√°-lo, da seguinte maneira: # Escrita dos dados em formato json no arquivo dados_do_solo.json jsonlite::write_json(df_solo_json, &quot;../data/5_arquivos_parte_r/dados_do_solo.json&quot;) Para realizar a leitura: # Leitura do arquivo em formato .json df_solo &lt;- jsonlite::read_json(&quot;../data/5_arquivos_parte_r/dados_do_solo.json&quot;, simplifyVector = TRUE) # Visualiza√ß√£o dos dados cat(df_solo) ## [ ## { ## &quot;label&quot;: &quot;Soja&quot;, ## &quot;plant_agri&quot;: true, ## &quot;plat_col&quot;: &quot;2019-09-01&quot; ## }, ## { ## &quot;label&quot;: &quot;Milho&quot;, ## &quot;plant_agri&quot;: true, ## &quot;plat_col&quot;: &quot;2019-01-10&quot; ## }, ## { ## &quot;label&quot;: &quot;Pastagem&quot;, ## &quot;plant_agri&quot;: false, ## &quot;plat_col&quot;: &quot;NA&quot; ## }, ## { ## &quot;label&quot;: &quot;Vegeta√ß√£o&quot;, ## &quot;plant_agri&quot;: false, ## &quot;plat_col&quot;: &quot;NA&quot; ## } ## ] De forma semelhante a leitura e escrita do arquivo em formato json, podemos salvar nossos dados de solo em formato tabular, por√©m, vamos usar o pacote readr, da seguinte forma: # Importa√ß√£o do pacote library(readr) # Escrita dos dados em formato csv no arquivo dados_do_solo.csv readr::write_csv(df_solo, &quot;../data/5_arquivos_parte_r/dados_do_solo.csv&quot;) Para fazer a leitura: # Leitura do arquivo em formato .csv df_solo_csv &lt;- readr::read_csv(&quot;../data/5_arquivos_parte_r/dados_do_solo.csv&quot;) ## Parsed with column specification: ## cols( ## label = col_character(), ## plant_agri = col_logical(), ## plat_col = col_date(format = &quot;&quot;) ## ) # Visualiza√ß√£o do conjunto de dados df_solo_csv ## # A tibble: 4 x 3 ## label plant_agri plat_col ## &lt;chr&gt; &lt;lgl&gt; &lt;date&gt; ## 1 Soja TRUE 2019-09-01 ## 2 Milho TRUE 2019-01-10 ## 3 Pastagem FALSE NA ## 4 Vegeta√ß√£o FALSE NA No entanto, nem tudo s√£o flores e t√£o simples quanto mostramos. Os m√©todos apresentados possuem diversos parametros que ajudam a lidar com dados mal formatados e ruidosos, ent√£o, salientamos que nosso exemplo √© de cunho acad√™mico. Como diz um dos criadores do Tidyverse: ‚ÄúOs conjuntos de dados arrumados s√£o todos iguais, mas todos os conjuntos de dados desorganizados s√£o desorganizados √† sua pr√≥pria maneira.‚Äù - Hadley Wickham 2.1.2 Manipula√ß√£o de dados Nesta subse√ß√£o, vamos nos basear no nosso livro-texto de Introdu√ß√£o √† An√°lise de Dados, fique √† vontade para contribuir com o material deste curso üëº. Para selecionar, filtrar e agrupar nossos dados, vamos usar o pacote dplyr, o qual est√° contido no kit de ferramentas Tidyverse. Vamos iniciar criando mais um conjunto de dados: # Cria√ß√£o do tibble df_escola &lt;- tibble::tibble( id = c(1, 2, 3, 4, 5, 6), curso = c(&quot;Historia&quot;, &quot;Historia&quot;, &quot;Matem√°tica&quot;, &quot;Estat√≠stica&quot;, &quot;Matem√°tica&quot;, &quot;Estat√≠stica&quot;), media = c(2.1, 3.5, 4.0, 1.0, NA, 4.9), conceito = c(&quot;C&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;, &quot;NA&quot;, &quot;A&quot;)) knitr::kable(df_escola) id curso media conceito 1 Historia 2.1 C 2 Historia 3.5 B 3 Matem√°tica 4.0 A 4 Estat√≠stica 1.0 C 5 Matem√°tica NA NA 6 Estat√≠stica 4.9 A Entre os diversos m√©todos ofericidos pelo pacote dplyr, vamos usar os seguintes: select - Sele√ß√£o de atributos de um data.frame ou tibble filter - Filtro de observa√ß√µes de acordo com uma l√≥gica pr√©-definida mutate - Cria√ß√£o de novos atributos group_by - Cria√ß√£o de grupos para aplica√ß√£o de fun√ß√µes de agrega√ß√£o summarize - Fun√ß√£o de agrega√ß√£o aplicada em grupos Vamos manipular nosso tibble com base nos m√©todos apresentados: # importa√ß√£o do pacote dplyr suppressMessages(library(dplyr)) # Filtro dos alunos com conceito igual a &quot;A&quot; filtro &lt;- dplyr::filter(df_escola, df_escola$conceito == &quot;A&quot;) # Sele√ß√£o dos atributos &quot;curso&quot;, &quot;conceito&quot; e &quot;media&quot; selecao &lt;- dplyr::select(filtro, curso, conceito, media) # Cria√ß√£o de grupos por curso grupo &lt;- dplyr::group_by(selecao, curso) # Agrega√ß√£o dos cursos pela m√©dia media &lt;- dplyr::summarize(grupo, media_grupo = mean(media)) # Visualiza√ß√£o dos dados knitr::kable(media) curso media_grupo Estat√≠stica 4.9 Matem√°tica 4.0 Basicamente, filtramos pelo atributo conceito, selecionamos os atributos curso, conceito e media, agrupamos pelos cursos e tiramos a m√©dia dos grupos formados üêª. Mas, ficou muito grande, podemos diminuir a quantidade de atribui√ß√µes utilizando pipe, desta forma: # importa√ß√£o do pacote magrittr library(magrittr) # Uso do pipe (%&gt;%) para filtrar, selecionar, agrupar e aplicar fun√ß√£o de # agrega√ß√£o df &lt;- df_escola %&gt;% dplyr::filter(conceito == &quot;A&quot;) %&gt;% dplyr::select(curso, conceito, media) %&gt;% dplyr::group_by(curso) %&gt;% dplyr::summarize(media_grupo = mean(media)) # Visualiza√ß√£o dos dados knitr::kable(df) curso media_grupo Estat√≠stica 4.9 Matem√°tica 4.0 A principal fun√ß√£o do pipe √© tornar o c√≥digo mais limpo e reprodut√≠vel. Desta forma, encerramos os m√©todos b√°sicos de manipula√ß√£o de dados. Na pr√≥xima subse√ß√£o, vamos usar o pacote sf para a leitura, escrita e manipu√ß√£o de dados espaciais. # Introdu√ß√£o √† Geoci√™ncias üåè 2.2 SF O pacote sf Pebesma (2018) implementa as simple features explicadas no cap√≠tulo 1 com base nas estruturas de data.frame ou tibble, as principais caracter√≠sticas do pacote pode ser vista na lista abaixo: - Representa√ß√£o nativa em R de todos os 17 tipos das simple features para todas as dimens√µes (XY, XYZ, XYM, XYZM). - Interface para o GEOS que suporta a DE9-IM. - Interface para o GDAL, a qual fornece suporte para todas op√ß√µes de drivers, tipo de atributo Date e DateTime e sistema de coordenadas de refer√™ncia atrav√©s do PROJ. - Uso de serializa√ß√µes escritas em Rcpp para otimizar o I/O com GDAL e GEOS. - Leitura e escrita de bancos de dados com extens√µes espaciais, por exemplo PostGIS. Lista retirada da p√°gina de documenta√ß√£o do pacote sf 2.2.1 Tipos Geom√©tricos Como apresentado no cap√≠tulo 1, podemos representar os tipos geom√©tricos com pontos, linhas e pol√≠gonos. Nesta subse√ß√£o, vamos apresentar alguns tipos geom√©tricos oferecidos pelo pacote sf que segue a implementa√ß√£o padr√£o da OGC. Para criarmos um simples POINT: # Impota√ß√£o do pacote library(sf) ## Linking to GEOS 3.5.1, GDAL 2.1.3, PROJ 4.9.3 # Cria√ß√£o de um ponto no plano ponto &lt;- sf::st_point(c(3, 4)) ponto ## POINT (3 4) Para criarmos uma LINESTRING: # Cria√ß√£o dos segmentos de reta linha &lt;- rbind(c(2, 1), c(4, 4), c(8, 2), c(4, 2) ) # Cria√ß√£o do linestring linestring &lt;- sf::st_linestring(linha) linestring ## LINESTRING (2 1, 4 4, 8 2, 4 2) Por fim, para criarmos um pol√≠gono sem buracos: # Cria√ß√£o dos segmentos de reta poligono &lt;- rbind(c(2, 1), c(1, 2), c(1, 5), c(5, 3), c(2, 1)) # Cria√ß√£o do poligono polygon &lt;- sf::st_polygon(list(poligono)) polygon ## POLYGON ((2 1, 1 2, 1 5, 5 3, 2 1)) Os tipos geom√©tricos criados s√£o apresentados abaixo: Como apresentado no cap√≠tulo 1, os tipos geom√©tricos podem ser usados em conjunto: MULTIPOINT, MULTILINESTRING, MULTIPOLYGON e GEOMETRYCOLLECTION. O trecho de c√≥digo abaixo apresenta a cri√ß√£o dos tipos mencionados: # Cria√ß√£o de pontos pontos &lt;- rbind(c(2,4), c(1,2), c(3,1), c(4,3), c(3,2)) # Cria√ß√£o do tipo geom√©trico multipoint multipoint &lt;- sf::st_multipoint(pontos) # Cria√ß√£o dos segmentos de reta linhas_s1 &lt;- rbind(c(1,3), c(4,4), c(5,2), c(3,0),c(1,1)) linhas_s2 &lt;- rbind(c(1,4), c(4,5), c(1,5)) # Cria√ß√£o do tipo geom√©trico multiline multilinestring &lt;- sf::st_multilinestring(list(linhas_s1, linhas_s2)) # Cri√ß√£o dos pol√≠gonos poligono_p1 &lt;- rbind(c(2,3), c(6,1), c(2,1), c(2,3)) poligono_p2 &lt;- rbind(c(6,5), c(4,4), c(6,2), c(8,4), c(6,5)) poligono_p2_1 &lt;- rbind(c(5,4), c(6,3), c(6,4), c(5,4)) # Cria√ß√£o do tipo geom√©trico multipolygon multipolygon &lt;- sf::st_multipolygon(list(list(poligono_p1), list(poligono_p2, poligono_p2_1))) # Cria√ß√£o do tipo geom√©trico geometrycollection &lt;- sf::st_geometrycollection(list(multipoint, multilinestring, multipolygon)) Os tipos geom√©tricos criados s√£o apresentados abaixo: OS tipos geom√©tricos que criamos s√£o objetos da classe sfg (Simple Feature Geometries), os quis possuem apenas um √∫nico atributo, correspondes aos pontos no plano ou espa√ßo. Para verificar a classe dos objetos: # Verifica√ß√£o da classe do tipo geom√©trico criado class(multipoint) ## [1] &quot;XY&quot; &quot;MULTIPOINT&quot; &quot;sfg&quot; Podemos representar uma lista de tipos geom√©tricos com a classe sfc (Simple Feature Columns), a qual cria atributos de objetos sfg, por exemplo: # Defini√ß√£o dos pontos ponto_1 &lt;- c(2,4) linha_1 &lt;- rbind(c(1,2), c(3,4)) # Cria√ß√£o dos objetos sfg point &lt;- sf::st_point(ponto_1) linestring &lt;- sf::st_linestring(linha_1) # Cria√ß√£o de um objeto sfc sfc_obj &lt;- sf::st_sfc(point, linestring) sfc_obj ## Geometry set for 2 features ## geometry type: GEOMETRY ## dimension: XY ## bbox: xmin: 1 ymin: 2 xmax: 3 ymax: 4 ## epsg (SRID): NA ## proj4string: NA ## POINT (2 4) ## LINESTRING (1 2, 3 4) Observe que, diferentemente dos tipos geom√©tricos da classe sfg, a classe sfc apresenta diferentes caracter√≠sticas, como a proje√ß√£o proj4string, ID do sistema de refer√™ncia geogr√°fica epsg, bolding box bbox e a dimens√£o dimension. No dia-a-dia vamos trabalhar com dados vetoriais provindos de diversas fontes, como IBGE e INPE. Logo, n√£o vamos precisar criar nossos tipos geom√©tricos e sim realizar a leitura dos arquivos que recebemos. Na subse√ß√£o seguinte, vamos aprender como fazer a leitura de arquivos vetoriais. 2.2.2 Leitura e escrita de dados vetoriais Os dados usados nesta subse√ß√£o se encontram dispon√≠veis em data neste diret√≥rio. O c√≥digo abaixo apresenta a leitura do arquivo vetorial que cont√™m os estados brasileiros: # Leitura do arquivos .shp que cont√™m as unidades federativas shp_brazil &lt;- sf::read_sf(&quot;../data/1_estados_do_brasil_shape/Brasil.shp&quot;) # Visualiza√ß√£o dos atributos .shp head(shp_brazil, 4) ## Simple feature collection with 4 features and 4 fields ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -73.99094 ymin: -11.14449 xmax: -35.15167 ymax: 4.437122 ## epsg (SRID): NA ## proj4string: +proj=longlat +ellps=aust_SA +no_defs ## # A tibble: 4 x 5 ## ESTADOS REGIAO COD_UF UF geometry ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;MULTIPOLYGON [¬∞]&gt; ## 1 Acre Norte 12 AC (((-73.80098 -7.111453, -73.74084 -7.14318‚Ä¶ ## 2 Alagoas Norde‚Ä¶ 27 AL (((-36.39119 -10.50082, -36.39864 -10.4978‚Ä¶ ## 3 &quot;Amap\\xe‚Ä¶ Norte 16 AP (((-51.3738 -0.3705301, -51.37337 -0.36712‚Ä¶ ## 4 Amazonas Norte 13 AM (((-73.80098 -7.111453, -73.80106 -7.11128‚Ä¶ Verifica√ß√£o da classe do arquivo: class(shp_brazil) ## [1] &quot;sf&quot; &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; Diferentemente dos tipos geom√©tricos que criamos anteriormente (sfg), objetos da classe sf possuem atributos que correspondem ao tipo geom√©tricos e as caracter√≠sticas do dado vetorial, ou seja, s√£o um jun√ß√£o entre as classes sfge sfc. Por exemplo, √© poss√≠vel observar o tipo geom√©trico dos estados brasileiros (MULTIPOLYGON), bem como as regi√µes de cada estado (REGIAO), representadas por um atributo discreto. O pacote sf, utilizando como base o GDAL, fornece suporte de leitura e escrita para diversos formatos, tais como: GeoJSON e KML. O c√≥digo abaixo mostra como salvar os tipos geom√©tricos de criamos anteriormente: # Transformando para texto gc_text &lt;- sf::st_as_text(geometrycollection) # Transformando para objeto sfc gc_sfc &lt;- sf::st_as_sfc(gc_text) # Escrita do tipo geom√©trico geometry collection em .shp sf::write_sf(gc_sfc, &quot;./dados/geometrycollection_curso.shp&quot;) Um breve resumos das classes do pacote SF: sfg √önico objeto geom√©trico, por exemplo, POINT. sfc Jun√ß√£o de tipos geom√©tricos da classe sfg. Possui informa√ß√µes como proje√ß√£o e sistema de refer√™ncia geog≈ïafica. sf Jun√ß√£o das classes sfg e sfc. Cont√™m atributos correspondes ao tipo geom√©tricos, bem como atributos discretos, categ√≥ricos que representam caracter√≠sticas do objeto. Agora que aprendemos a diferen√ßa entre cada classe do pacote sf e como fazer a leitura e escrita de dados vetoriais, na subse√ß√£o seguinte vamos aprender sobre os relacionamentos espaciais, de acordo com a Matriz de 9-interse√ß√µes Estendida Dimensionalmente (DE-9IM). 2.2.3 Relacionamentos Espaciais Para realizar a an√°lise de dados espaciais √© necess√°rio o uso de diversos m√©todos espaciais, com a finalidade de verificar se dois objetos possuem alguma rela√ß√£o, por exemplo, para identificar a quantidade de focos de queimada no estado de S√£o Paulo. Assim, o uso de tais m√©todos se tornam indispens√°veis durante a manipula√ß√£o de dados espaciais. Os m√©todos apresentados nesta subse√ß√£o: Equals - Verifica se duas geom√©trias s√£o iguais; Disjoint - Verifica se duas geom√©trias s√£o disjuntas; Touches - Verifica se duas geom√©tricas se tocam; Crosses - Verifica se duas geom√©tricas se cruzam; Within- Verifica se a geom√©tria A est√° contida em B; Contains - Verifica se a geom√©tria B cont√™m; Overleaps - Verifica se duas geom√©trias se sobrep√µem; Intersects - Verifica se duas geom√©tricas se interseccionam. 2.2.3.1 Equals # Defini√ß√£o dos pontos poligono_1 &lt;- rbind(c(1,1), c(1,5), c(5,5), c(1,1)) poligono_2 &lt;- rbind(c(5,3), c(5,5), c(3,5), c(1,5), c(1,3), c(1,1), c(3,1), c(5,1), c(5,3)) # Cria√ß√£o dos tipos geom√©tricos polygon_a &lt;- sf::st_polygon(list(poligono_1)) polygon_b &lt;- sf::st_polygon(list(poligono_2)) Para saber se duas geom√©trias s√£o iguais, usa-se o m√©todos st_equals: # Verifica se duas geom√©trias s√£o iguais sf::st_equals(polygon_a, polygon_b, sparse = FALSE) ## [,1] ## [1,] FALSE O retorno do m√©todo √© um lista com tamanho 1, com valores bin√°rios, TRUE ou FALSE. Desta forma, os pol√≠gonos criados n√£o s√£o iguais, pois o pol√≠gono B possui mais pontos. O c√≥digo abaixo a apresenta a verifica√ß√£o de dois pontos: # Cria√ß√£o dos pontos ponto_1 &lt;- sf::st_point(c(1,1)) ponto_2 &lt;- sf::st_point(c(1,1)) # Verifica se duas geom√©trias s√£o iguais sf::st_equals(ponto_1, ponto_2, sparse = FALSE) ## [,1] ## [1,] TRUE Para verificar se duas geom√©tricas s√£o exatamente iguais, use st_equals_exact. 2.2.3.2 Disjoint # Cria√ß√£o dos linestrings segmento_1 &lt;- rbind(c(1.5,5), c(3,5), c(4,6), c(6,5)) segmento_2 &lt;- rbind(c(1,6), c(1,4), c(4,4)) # Cria√ß√£o dos tipos geom√©tricos linestring linestring_1 &lt;- sf::st_linestring(segmento_1) linestring_2 &lt;- sf::st_linestring(segmento_2) Para saber se duas geom√©trias s√£o disjuntas, usa-se o m√©todos st_disjoint: # Verifica se duas geom√©trias s√£o disjuntas sf::st_disjoint(linestring_1,linestring_2, sparse = FALSE) ## [,1] ## [1,] TRUE Outro exemplo: # Cria√ß√£o dos pol√≠gonos poligono_1 &lt;- rbind(c(1,1), c(1,2), c(3,2), c(3,2), c(3,1), c(1,1)) poligono_2 &lt;- rbind(c(3,3), c(5,3), c(5,2), c(3,2), c(3,3)) # Cria√ß√£o dos tipos geom√©tricos polygons polygon_1 &lt;- sf::st_polygon(list(poligono_1)) polygon_2 &lt;- sf::st_polygon(list(poligono_2)) # Verifica se duas geom√©trias s√£o disjuntas sf::st_disjoint(polygon_1,polygon_2, sparse = FALSE) ## [,1] ## [1,] FALSE 2.2.3.3 Touches # Cria√ß√£o dos pol√≠gonos poligono_1 &lt;- rbind(c(1, 1), c(1, 3), c(4, 3), c(4,1), c(1,1)) poligono_2 &lt;- rbind(c(4,2), c(4,4), c(6,4), c(6,2), c(4,2)) # Cria√ß√£o dos tipos geom√©tricos polygon_1 &lt;- sf::st_polygon(list(poligono_1)) polygon_2 &lt;- sf::st_polygon(list(poligono_2)) Para verificar se duas geom√©trias se tocam, usa-se o m√©todo st_touches: # Verifica se duas geom√©trias se tocam sf::st_touches(polygon_1, polygon_2, sparse = FALSE) ## [,1] ## [1,] TRUE Outro exemplo: # Cria√ß√£o dos segmentos segmento_1 &lt;- rbind(c(5,6), c(5,8), c(7,8)) segmento_2 &lt;- rbind(c(6,6), c(6,9)) # Cria√ß√£o dos tipos geom√©tricos linestring_1 &lt;- sf::st_linestring(segmento_1) linestring_2 &lt;- sf::st_linestring(segmento_2) # Verifica se duas geom√©trias se tocam sf::st_touches(linestring_1, linestring_2, sparse = FALSE) ## [,1] ## [1,] FALSE 2.2.3.4 Crosses # Cria√ß√£o da reta e pol√≠gono segmento_1 &lt;- rbind(c(11,5), c(13,5), c(13,6)) poligono_1 &lt;- rbind(c(12,4), c(12,7), c(15,4), c(12,4)) # Cria√ß√£o dos objetos geom√©tricos linestring_1 &lt;- sf::st_linestring(segmento_1) polygon_1 &lt;- sf::st_polygon(list(poligono_1)) Para verificar se duas geom√©trias se tocam, usa-se o m√©todo st_touches: # Verifica se duas geom√©trias se cruzam sf::st_crosses(linestring_1, polygon_1, sparse = FALSE) ## [,1] ## [1,] TRUE Outro exemplo: # Cria√ß√£o da reta e dos pontos segmento_1 &lt;- rbind(c(8,1), c(8,3), c(10,3)) ponto_1 &lt;- rbind(c(9,2), c(9,3), c(10,2)) # Cria√ß√£o dos objetos geom√©tricos linestring_1 &lt;- sf::st_linestring(segmento_1) multipoint_1 &lt;- sf::st_multipoint(ponto_1) # Verifica se duas geom√©trias se cruzam sf::st_crosses(linestring_1, multipoint_1, sparse = FALSE) ## [,1] ## [1,] TRUE 2.2.3.5 Within # Cria√ß√£o dos pol√≠gonos poligono_1 &lt;- rbind(c(2,2), c(2,4), c(4,4), c(4,2), c(2,2)) poligono_2 &lt;- rbind(c(1,1), c(1,5), c(5,5), c(5,1), c(1,1)) # Cria√ß√£o dos objetos geom√©tricos polygon_1 &lt;- sf::st_polygon(list(poligono_1)) polygon_2 &lt;- sf::st_polygon(list(poligono_2)) Para verificar se o pol√≠gono 1 est√° dentro do pol√≠gono 2, usa-se o m√©todo st_within: # Verifica se o poligono 1 est√° dentro do pol√≠gono 2 sf::st_within(polygon_1, polygon_2, sparse=FALSE) ## [,1] ## [1,] TRUE 2.2.3.6 Contains # Cria√ß√£o do ponto e do pol√≠gono poligono_1 &lt;- rbind(c(1,6), c(1,9), c(5,9), c(5,6), c(1,6)) ponto_1 &lt;- c(3,8) # Cria√ß√£o dos tipos geom√©tricos polygon_1 &lt;- sf::st_polygon(list(poligono_1)) point_1 &lt;- sf::st_point(ponto_1) Para verificar se o pol√≠gono 1 cont√©m o ponto 1, usa-se o m√©todo st_contains: # Verifica se o poligono 1 cont√©m o ponto 1 sf::st_contains(polygon_1, point_1, sparse = FALSE) ## [,1] ## [1,] TRUE 2.2.3.7 Overlaps # Cria√ß√£o dos pol√≠gonos poligono_1 &lt;- rbind(c(7,1), c(7,3), c(10,3), c(10,1), c(7,1)) poligono_2 &lt;- rbind(c(13,1), c(9,2), c(13,4), c(13,1 )) # Cria√ß√£o dos tipos geom√©tricos polygon_1 &lt;- sf::st_polygon(list(poligono_1)) polygon_2 &lt;- sf::st_polygon(list(poligono_2)) Para verificar se o pol√≠gono 1 sobrep√µe o pol√≠gono 2, usa-se o m√©todo st_overlaps: # Verifica se o poligono 1 sobrep√µe o poligono 2 sf::st_overlaps(polygon_1, polygon_2, sparse = FALSE) ## [,1] ## [1,] TRUE Outro exemplo: # Cria√ß√£o das retas segmento_1 &lt;- rbind(c(8,8), c(12,8)) segmento_2 &lt;- rbind(c(9,6), c(9,8), c(11,8), c(11,9)) # Cria√ß√£o dos tipos geom√©tricos linestring_1 &lt;- sf::st_linestring(segmento_1) linestring_2 &lt;- sf::st_linestring(segmento_2) # Verifica se a linestring 1 sobrep√µe a linestring 2 sf::st_overlaps(linestring_1, linestring_2, sparse = FALSE ) ## [,1] ## [1,] TRUE 2.2.3.8 Intersects # Cria√ß√£o dos pol√≠gonos poligono_1 &lt;- rbind(c(1,7), c(1,9), c(5,9), c(5,7), c(1,7)) poligono_2 &lt;- rbind(c(4,6), c(4,8), c(8,8), c(8,6), c(4,6)) # Cria√ß√£o dos tipos geom√©tricos polygon_1 &lt;- sf::st_polygon(list(poligono_1)) polygon_2 &lt;- sf::st_polygon(list(poligono_2)) Para verificar se o pol√≠gono 1 intersecta o pol√≠gono 2, usa-se o m√©todo st_intersects: sf::st_intersects(polygon_1, polygon_2, sparse=FALSE) ## [,1] ## [1,] TRUE 2.2.4 Operadores M√©tricos Os operadores e os dados apresentados nesta subse√ß√£o, est√£o presentes na se√ß√£o de Python e PostGIS. A se√ß√£o em Python cobre com mais detalhes cada operador. Nesta subse√ß√£o vamos usar tais operadores m√©tricos: - st_area - √Årea de um tipo geom√©trico poligonal - st_length - Comprimento de tipos geom√©tricos 1D (LINESTRING) 2.2.4.1 √Årea Vamos calcular a √°rea do estado de estado do Rio de Janeiro, para isso vamos utilizar tudo que aprendemos at√© agora: # Importa√ß√£o do ggplot2 para visualiza√ß√£o de dados library(ggplot2) # Leitura do shp que cont√©m os estados brasileiros shp_brazil &lt;- sf::read_sf(&quot;../data/1_estados_do_brasil_shape/Brasil.shp&quot;) # Sele√ß√£o do estado do Rio de Janeiro estado_rj &lt;- shp_brazil %&gt;% dplyr::filter(ESTADOS==&quot;Rio de Janeiro&quot;) # Visualiza√ß√£o ggplot2::theme_set(ggplot2::theme_bw()) ggplot2::ggplot() + geom_sf(data = estado_rj) + labs(x = &quot;Longitude&quot;, y = &quot;Latitude&quot;, title = &quot;Limites do estado do Rio de Janeiro&quot;) # C√°lculo da √°rea em metros quadrados area_rj &lt;- sf::st_area(estado_rj) area_rj ## 43791834545 [m^2] Podemos converter a √°rea para \\(Km^2\\) para facilitar a compara√ß√£o dos resultados. # Convers√£o para km^2 area_rj &lt;- area_rj/1e+6 area_rj ## 43791.83 [m^2] Segundo o IBGE (Instituto Brasileiro de Geografia e Estat√≠stica), a √°rea do estado do Rio de Janeiro correspnde a \\(43.781,588 Km^2\\) e a √°rea da retornada pela nossa consulta \\(43.791,83 Km^2\\). A diferen√ßa foi relativamente baixa, mostrando a efic√°cia do m√©todo no c√°lculo da √°rea. 2.2.4.2 Comprimento Assim como a √°rea, vamos utilizar todos os conceitos vistos at√© agora no minicurso. Vamos medir o comprimento do Rio Para√≠ba do Sul, o trecho de c√≥digo abaixo apresenta a leitura dos rios de todo o territ√≥rio brasileiro: Todos os dados usados neste minicurso est√£o no diret√≥rio data # Leitura do shapefile rios_brazil &lt;- sf::read_sf(&quot;../data/4_rios_brasil/Brasil_rios.shp&quot;) # Visualiza√ß√£o dos dados head(rios_brazil, 4) ## Simple feature collection with 4 features and 7 fields ## geometry type: MULTILINESTRING ## dimension: XY ## bbox: xmin: -67.34078 ymin: -6.052164 xmax: -36.73497 ymax: 1.997553 ## epsg (SRID): NA ## proj4string: +proj=longlat +ellps=aust_SA +no_defs ## # A tibble: 4 x 8 ## OBJECTID IDRIO CORIO NORIOCOMP NUDISTBACR NUCOMPRIO DSVERSAO ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 1 47715 7516‚Ä¶ Rio Cani‚Ä¶ 63.8 134. BHO 201‚Ä¶ ## 2 2 35341 7522‚Ä¶ Riacho C‚Ä¶ 346. 42.1 BHO 201‚Ä¶ ## 3 3 36318 7561‚Ä¶ Riacho C‚Ä¶ 116. 45.9 BHO 201‚Ä¶ ## 4 4 50455 48_0 Rio Negro 1430. 1347. BHO 201‚Ä¶ ## # ‚Ä¶ with 1 more variable: geometry &lt;MULTILINESTRING [¬∞]&gt; Vamos filtrar pelo Rio Para√≠ba do Sul: # Filtro do rio paraiba do sul rio_paraiba &lt;- rios_brazil %&gt;% dplyr::filter(NORIOCOMP == &quot;Rio Para√≠ba do Sul&quot;) # Comprimeiro do rio paraiba do sul rio_paraiba_comp &lt;- sf::st_length(rio_paraiba) rio_paraiba_comp ## 868441.2 [m] Para fazer a convers√£o vamos utilizar o pacote units: # Importa√ß√£o do pacote units library(units) ## udunits system database from /usr/share/xml/udunits # Convers√£o para km rio_paraiba_comp &lt;- units::set_units(rio_paraiba_comp, km) rio_paraiba_comp ## 868.4412 [km] Segundo a Wikipedia, o comprimento do Rio Para√≠ba do Sul correponde a \\(1.137 Km\\) e o nosso m√©todo obteve \\(\\approx 868 Km\\). Os exerc√≠cios apresentados foram retirados do material da disciplina de Banco de Dados Geogr√°ficos 2.2.5 Sistemas de refer√™ncias Como apresentado no cap√≠tulo 1, podemos representar nossos dados espaciais utilizando diversos tipos de proje√ß√µes. Desta forma, nesta subse√ß√£o vamos aprender como realizar a convers√£o e a transforma√ß√£o dos nossos dados. O trecho de c√≥digo abaixo mostra como verificar qual a proje√ß√£o dos nossos dados. # Verifica o sistema de referencia geogr√°fica sf::st_crs(shp_brazil) ## Coordinate Reference System: ## No EPSG code ## proj4string: &quot;+proj=longlat +ellps=aust_SA +no_defs&quot; O trecho de c√≥digo acima mostra que nenhum EPSG foi definido, para conveter podemos usar o mesmo m√©todo: # Convers√£o do sistema de refer√™ncia geogr√°fica sf::st_crs(shp_brazil) &lt;- 4326 ## Warning: st_crs&lt;- : replacing crs does not reproject data; use st_transform ## for that sf::st_crs(shp_brazil) ## Coordinate Reference System: ## EPSG: 4326 ## proj4string: &quot;+proj=longlat +datum=WGS84 +no_defs&quot; Agora que definimos nosso ESPG, vamos visualizar as coordenadas geogr√°ficas: # Visualiza√ß√£o das tr√™s primeiras localiza√ß√µes head(shp_brazil$geometry, 3) ## Geometry set for 3 features ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -73.99094 ymin: -11.14449 xmax: -35.15167 ymax: 4.437122 ## epsg (SRID): 4326 ## proj4string: +proj=longlat +datum=WGS84 +no_defs ## MULTIPOLYGON (((-73.80098 -7.111453, -73.74084 ... ## MULTIPOLYGON (((-36.39119 -10.50082, -36.39864 ... ## MULTIPOLYGON (((-51.3738 -0.3705301, -51.37337 ... √â poss√≠vel observar que as coordenadas est√£o em graus, no entanto, e se quisermos trabalhar com metros? √â s√≥ fazer a convers√£o? # Convers√£o para metros usando WGS 84 na zona 23S sf::st_crs(shp_brazil) &lt;- 32723 ## Warning: st_crs&lt;- : replacing crs does not reproject data; use st_transform ## for that head(shp_brazil$geometry, 3) ## Geometry set for 3 features ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -73.99094 ymin: -11.14449 xmax: -35.15167 ymax: 4.437122 ## epsg (SRID): 32723 ## proj4string: +proj=utm +zone=23 +south +datum=WGS84 +units=m +no_defs ## MULTIPOLYGON (((-73.80098 -7.111453, -73.74084 ... ## MULTIPOLYGON (((-36.39119 -10.50082, -36.39864 ... ## MULTIPOLYGON (((-51.3738 -0.3705301, -51.37337 ... O m√©todo de convers√£o n√£o faz transforma√ß√£o das coordenadas geogr√°ficas. Para fazer a transforma√ß√£o, podemos usar o m√©todod st_transform: # Convers√£o do sistema de refer√™ncia geogr√°fica sf::st_crs(shp_brazil) &lt;- 4326 ## Warning: st_crs&lt;- : replacing crs does not reproject data; use st_transform ## for that # Transforma√ß√£o para metros usando WGS 84 na zona 23S shp_brazil &lt;- sf::st_transform(shp_brazil, 32723) head(shp_brazil$geometry, 3) ## Geometry set for 3 features ## geometry type: MULTIPOLYGON ## dimension: XY ## bbox: xmin: -2839595 ymin: 8649068 xmax: 1587862 ymax: 10493640 ## epsg (SRID): 32723 ## proj4string: +proj=utm +zone=23 +south +datum=WGS84 +units=m +no_defs ## MULTIPOLYGON (((-2819509 9103452, -2811689 9099... ## MULTIPOLYGON (((1445354 8826197, 1444540 882654... ## MULTIPOLYGON (((-210707.1 9958789, -210659.5 99... 2.2.6 Materiais recomendados Rafael Santos Disciplina de Banco de Dados Geogr√°fico - CAP349 "],
["python.html", "3 Python ‚ú® 3.1 Pandas üêº 3.2 GeoPandas üåçüêº", " 3 Python ‚ú® Python √© uma linguagem de programa√ß√£o vers√°til, multiparadigma, que permite aos desenvolvedores criar r√°pidas solu√ß√µes para seus problemas sem grandes preocupa√ß√µes com a sintaxe e formas de uso da linguagem. Tais caracter√≠sticas fizem Python alcan√ßar os mais variados nichos de aplica√ß√£o. Por ser uma linguagem geral para atingir tais nichos, foram criadas pela comunidade de Python diversas bibliotecas, todas seguindo a ideia da simplicidade de aplica√ß√£o e prototipa√ß√£o da linguagem. √â neste contexto que surge o GeoPandas, que fornece extens√µes de uso espacial para uma biblioteca de an√°lise de dados muito conhecida na comunidade Python, o Pandas. Desta forma, este cap√≠tulo busca explicar as principais formas de utiliza√ß√£o do GeoPandas. Por ser baseada no Pandas, h√° uma pequena se√ß√£o que trata sobre o uso b√°sico da linguagem, mas √© recomendado que o leitor tamb√©m conhe√ßa tal biblioteca, para isto, existe o curso de introdu√ß√£o √† an√°lise de dados, que explica os principais conceitos de utiliza√ß√£o do Pandas, n√£o deixe de conferir! 3.1 Pandas üêº Com a necessidade de facilitar todo o processo de an√°lise de dados, atrav√©s de uma linguagem simples e amig√°vel, a comunidade Python criou o Pandas, uma biblioteca que disponibiliza m√©todos de alto n√≠vel para a manipula√ß√£o, processamento e an√°lise dos mais variados tipos de dados. Atrav√©s dos m√©todos desta biblioteca √© poss√≠vel aplicar todo o ciclo de an√°lise de dados, este indo desde a coleta at√© o processamento e an√°lise. Para realizar tais atividades, o pandas disponibiliza diversas estruturas de dados, sendo as Series e os DataFrames as principais. Cada uma dessas estruturas de dados, trata especificamente de uma forma de realizar a abstra√ß√£o do formato dos dados em c√≥digo, isto faz com que seja necess√°rio o entendimento das principais diferentes entre cada uma delas, para que seja poss√≠vel realizar sua correta aplica√ß√£o. Vamos buscar comparar cada uma dessas estruturas para entender suas diferen√ßas. As Series s√£o estruturas de dados unidimensionais, possuindo apenas uma dimens√£o que pode ser manipulada, tal dimens√£o sendo chamada de √≠ndice. J√° os DataFrames apresentam duas dimens√µes para a manipula√ß√£o. Estas caracter√≠sticas, na pr√°tica, indicam que, as Series apenas representar vetores, enquanto os DataFrames podem representar matrizes de N-Dimens√µes. Para esta ideia ficar clara, vejamos a Figura abaixo. Perceba que, as Series possuem o campo para o armazenamento dos dados (Representado em Azul), e o √≠ndice (Representado em roxo), n√£o podendendo ser adicionado nenhum outro campo, isto faz com que, todos os dados tenham de ser armazenados em apenas uma coluna, em v√°rias linhas. Para o DataFrame o cen√°rio apresentado na Figura √© diferente, al√©m dos √≠ndices, h√° tamb√©m as colunas (Representada em vermelho), o que permite que dentro desta estrutura existam n√£o s√≥ um conjunto de linhas, como as Series mas sim um conjunto de colunas, onde cada uma dessas possuem v√°rias linhas. Na pr√°tica o que fica subentendido √© que, os DataFrames s√£o um conjunto de Series. Isto ocorre j√° que, cada uma das colunas criadas dentro do DataFrame s√£o Series, o que acaba gerando um efeito muito interessante na API do Pandas, boa parte dos m√©todos dispon√≠veis para as Series tamb√©m est√£o presentes nos DataFrames. Vamos ver alguns exemplos em c√≥digo para fixar a diferen√ßa entre essas duas estruturas de dados. 3.1.1 Manipula√ß√£o de dados Vamos come√ßar criando uma Series. import pandas as pd sr = pd.Series([1, 2, 3, 4, 5]) Pronto! Acabamos de criar uma Series com uma lista de valores, vejamos como ela est√° sendo representada. print(sr) ## 0 1 ## 1 2 ## 2 3 ## 3 4 ## 4 5 ## dtype: int64 A representa√ß√£o est√° da mesma forma que vimos antes. Vamos agora fazer uma pequena manipula√ß√£o dos dados, para isto, utilizaremos os m√©todos loc e iloc dispon√≠veis dentro do objeto Series gerado, onde o m√©todo loc busca o √≠ndice com o nome inserido e o iloc busca o √≠ndice com a posi√ß√£o inserida. A assinatura de cada um dos m√©todos est√° descrita abaixo. Lembre-se que este m√©todo est√° presente tanto na classe Series como na classe DataFrame. DataFrame Series .loc[linha, coluna] .loc[linha] .iloc[linha] .iloc[linha] Antes de fazermos o teste destes m√©todos, vamos alterar o √≠ndice da nossa Series. # Vamos visualizar o √≠ndice print(sr.index) ## RangeIndex(start=0, stop=5, step=1) O atributo index devolve os elementos que est√£o no √≠ndice, para fazer sua mudan√ßa, basta realizar uma atribui√ß√£o, veja. sr.index = [&quot;um&quot;, &quot;dois&quot;, &quot;tres&quot;, &quot;quatro&quot;, &quot;cinco&quot;] print(sr.index) ## Index([&#39;um&#39;, &#39;dois&#39;, &#39;tres&#39;, &#39;quatro&#39;, &#39;cinco&#39;], dtype=&#39;object&#39;) Fizemos esta mudan√ßa, para que cada um dos m√©todos loc e iloc seja mais simples de entender. Certo, vamos come√ßar buscando a linha que tenha o nome dois. print(sr.loc[&quot;dois&quot;]) ## 2 Agora vamos buscar a linha que est√° na posi√ß√£o dois. print(sr.iloc[1]) # Lembre-se, o Python come√ßa a contar no zero =D ## 2 Percebeu? Temos o mesmo resultado, muito interessante n√£o ? Al√©m disso ainda posso aplicar filtros sob os dados,utilizando o conceito de indexa√ß√£o booleana, onde atrav√©s de um vetor de VERDADEIRO e FALSO √© poss√≠vel selecionar as linhas. Vamos buscar somente os valores que s√£o acima de tr√™s. print(sr[sr &gt; 3]) ## quatro 4 ## cinco 5 ## dtype: int64 Dica: O que ocorre nesta parte √©, dentro das chaves de sr (sr[]) √© passado a express√£o sr &gt; 3 que devolve uma lista de verdadeiros e falsos, fazendo assim o filtro. Muito interessante! Mas at√© aqui trabalhamos com apenas uma dimens√£o, vamos tentar acrescentar mais, para isto, primeiro vamos criar uma matriz. matriz = [ [1, 2, 3], [4, 5, 6] ] A matriz criada √© representada por uma lista de listas. Vamos tentar criar uma Series com esta matriz. sr = pd.Series(matriz) print(sr) ## 0 [1, 2, 3] ## 1 [4, 5, 6] ## dtype: object Eita! Perceba que, em cada linha h√° uma lista de valores, o que √© ruim! J√° que a manipula√ß√£o fica dif√≠cil (Tenta fazer uma indexa√ß√£o booleana, vai falhar üò¢). Para este caso, existem os DataFrames! Vamos come√ßar criando um com a mesma matriz gerada anteriormente. df = pd.DataFrame(matriz) print(df) ## 0 1 2 ## 0 1 2 3 ## 1 4 5 6 Opa! Agora o cen√°rio √© outro, conseguimos colocar cada um dos valores em seu devido lugar. Perceba que a representa√ß√£o mudou bastante, aqui temos v√°rias colunas de dados, e mesmo assim, todos os m√©todos j√° apresentados at√© aqui funcionam. Vai l√°, tenta! Uma coisa importante sobre os DataFrames s√£o suas colunas, para acessar elas podemos fazer da seguinte forma. print(df[0]) ## 0 1 ## 1 4 ## Name: 0, dtype: int64 Viu! Estamos acessando a primeira coluna, se fizermos a mesma coisa, com a segunda tamb√©m vai funcionar (Tenta inserir o n√∫mero 1, para voc√™ ver o que acontece). Dica: Ao fazer df[0], estamos buscando o ‚Äúnome‚Äù da coluna, e n√£o sua posi√ß√£o Da mesma forma que eu podemos recuperar o √≠ndice com o atributo index podemos recuperar as colunas com o atributo columns print(df.columns) ## RangeIndex(start=0, stop=3, step=1) Para fazer a mudan√ßa dos nomes de cada coluna a mesma regra do index √© v√°lida. df.columns = [&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;] print(df.columns) ## Index([&#39;col1&#39;, &#39;col2&#39;, &#39;col3&#39;], dtype=&#39;object&#39;) Vamos recuperar a primeira coluna novamente print(df[&quot;col1&quot;]) ## 0 1 ## 1 4 ## Name: col1, dtype: int64 Assim, fica mais f√°cil entender que, quando se trata de colunas, estamos buscando os nomes, e n√£o simplesmente as posi√ß√µes. Bom, agora que j√° entendemos toda a utiliza√ß√£o b√°sica do Pandas, vamos come√ßar a falar um pouco sobre o GeoPandas üíú 3.2 GeoPandas üåçüêº Com o entendimento do que √© a biblioteca Pandas, suas estruturas de dados e principais caracter√≠sticas, o estudo do GeoPandas pode ser iniciado. Mas o que √© o GeoPandas ? GeoPandas √© um projeto open-source que busca facilitar o trabalho com dados vetoriais em Python, para isto, tem como base as estruturas de dados do Pandas Desta forma, a ideia b√°sica por tr√°s do GeoPandas √© adicionar o suporte a manipula√ß√£o de dados espaciais as estruturas de dados do Pandas, e com isto prover formas de manipula√ß√£o simples e direta a tais dados. Para fazer isto, o GeoPandas utiliza estruturas de dados geom√©tricas implementadas pela biblioteca Shapely dentro das Series e dos DataFrames. Com esta adi√ß√£o, duas estruturas de dados surgem, as GeoSeries e os GeoDataFrames. Este conceito pode ser melhor entendido com a observa√ß√£o da Figura abaixo. Perceba que, h√° a mesma estrutura que foi apresentada na se√ß√£o anterior, com as geometrias sendo o diferencial nas estruturas de dados. Na pr√°tica o que ocorre √©, todas as formas de manipula√ß√£o geom√©tricas, que como citadas s√£o implementadas com o Shapely, s√£o implementadas em uma classe GeoPandasBase que √© extendida pelas GeoSeries e GeoDataFrames, da mesma forma, essas tamb√©m extendem as estruturas de dados equivalentes do Pandas, veja a Figura abaixo. Como a GeoSeries e os GeoDataFrames s√£o especializa√ß√µes diretas das Series e dos DataFrames as mesmas caracter√≠sticas s√£o mantidas, onde, respectivamente, um armazena apenas uma coluna de valores, tendo uma dimens√£o de manipula√ß√£o e o outro armazena diversas colunas com duas dimens√µes de manipula√ß√£o, da mesma forma como apresentado na se√ß√£o anterior. Para fixar o funcionamento de cada uma dessas estruturas, vamos fazer alguns testes com a API do GeoPandas. 3.2.1 GeoSeries e GeoDataFrames Para come√ßar os testes, vamos importar a biblioteca de geometrias, Shapely e o GeoPandas. import shapely import geopandas as gpd Agora, vamos criar uma GeoSeries. gsr = gpd.GeoSeries([ shapely.geometry.Point(1, 1) ]) Dica: A geometria criada n√£o possui qualquer tipo de refer√™ncia espacial, portanto representa apenas um ponto no plano cartesiano. Veja que acabamos de criar uma GeoSeries que armazena uma geometria de ponto, vamos visualizar o objeto criado. print(gsr) ## 0 POINT (1.00000 1.00000) ## dtype: geometry A forma √© exatamente a mesma de uma Series. Vamos criar um novo objeto com mais geometrias inseridas. gsr = gpd.GeoSeries([ shapely.geometry.Point(1, 1), shapely.geometry.Point(2, 2), shapely.geometry.Point(4, 3) ]) print(gsr) ## 0 POINT (1.00000 1.00000) ## 1 POINT (2.00000 2.00000) ## 2 POINT (4.00000 3.00000) ## dtype: geometry Caso eu queira visualizar n√£o s√≥ a tabela, mas sim a representa√ß√£o das geometrias criadas no espa√ßo, √© poss√≠vel utilizar o m√©todo plot. gsr.plot() Mas as GeoSeries podem ser limitadas em alguns casos, imagine que para a realiza√ß√£o de um estudo seja necess√°rio n√£o s√≥ a geolocaliza√ß√£o ou a representa√ß√£o geom√©trica no espa√ßo, mas tamb√©m caracter√≠sticas do ambiente, qualquer tipo de informa√ß√£o que n√£o a espacial. Nestes casos podemos utilizar os GeoDataFrames que al√©m de colunas de geometria permitem o armazenamento de outras informa√ß√µes, isto por permitir multiplas colunas. Vamos criar um para fazer testes. gdf = gpd.GeoDataFrame({ &#39;atributo_a&#39;: [10, 11, 12], &#39;geometria&#39;: [ shapely.geometry.Point(1, 1), shapely.geometry.Point(2, 2), shapely.geometry.Point(4, 3) ] }) Visualizando o resultado print(gdf) ## atributo_a geometria ## 0 10 POINT (1 1) ## 1 11 POINT (2 2) ## 2 12 POINT (4 3) Agora as geometrias passam a ser vinculadas com outros valores, o que pode ser muito √∫til em v√°rios cen√°rios. At√© aqui foram criadas geometrias sem nenhum tipo de liga√ß√£o com o mundo real, ent√£o, vamos agora trabalhar um pouco com dados que fa√ßam esta representa√ß√£o, para isto, vejamos como carregar dados espaciais com o GeoPandas. 3.2.2 Leitura e escrita de dados Al√©m de todas as caracter√≠sticas citadas at√© aqui, o GeoPandas ainda ajuda na leitura e na escrita de dados vetoriais, tudo seguindo o padr√£o de facilidade de uso do Pandas. Para realizar essas opera√ß√µes o GeoPandas utiliza como base a biblioteca Fiona, que traz suporte a leitura e escrita de uma enorme variedade de formatos vetoriais, sendo alguns deles: GeoJSON; GPSTrackMaker; ESRI Shapefile; FileGDB; OpenFileGDB. Al√©m destes formatos a biblioteca aceita v√°rios outros, para a lista completa de formatos suportados, consulte a documenta√ß√£o do Fiona. Para fazer alguns testes utilizando as funcionalidades de leitura dos dados, vamos carregar um dado vetorial, dos estados do Brasil que est√£o armazenados em um shapefile. gdf = gpd.read_file(&quot;../data/1_estados_do_brasil_shape/Brasil.shp&quot;) Estes dados est√£o dispon√≠veis no reposit√≥rio do curso. Com os dados carregados, vamos visualizar qual foi a estrutura gerada ao carregar os dados. print(type(gdf)) ## &lt;class &#39;geopandas.geodataframe.GeoDataFrame&#39;&gt; Um GeoDataFrame! Isto √© feito por padr√£o pela biblioteca, assim, independente do formato de entrada, o GeoPandas busca inserir os dados dentro de um GeoDataFrame. Certo, vamos olhar ent√£o o que est√° dentro deste objeto. print(gdf.head(5)) ## ESTADOS REGIAO COD_UF UF geometry ## 0 Acre Norte 12.0 AC POLYGON ((-73.80098 -7.11145, -73.74084 -7.143... ## 1 Alagoas Nordeste 27.0 AL MULTIPOLYGON (((-36.39119 -10.50082, -36.39864... ## 2 Amap√° Norte 16.0 AP MULTIPOLYGON (((-51.37380 -0.37053, -51.37337 ... ## 3 Amazonas Norte 13.0 AM POLYGON ((-73.80098 -7.11145, -73.80106 -7.111... ## 4 Bahia Nordeste 29.0 BA MULTIPOLYGON (((-46.32975 -13.25248, -46.33072... √â poss√≠vel perceber neste resultado que, ao carregar os dados, as representa√ß√µes espaciais presentes no arquivo, foram inseridas em uma coluna chamada geometry e que, al√©m dessa coluna, existem outras que vinculam m√∫ltiplas informa√ß√µes a cada uma das representa√ß√µes espaciais presentes no arquivo. Lembre-se, o m√©todo head √© herdado do Pandas, ele possibilita a visualiza√ß√£o das linhas iniciais da tabela de dados. A representa√ß√£o acima n√£o nos mostra todas as colunas de informa√ß√µes que temos no conjunto de dados carregados, para saber quais s√£o todas elas, utilizaremos o atributo columns. print(gdf.columns) ## Index([&#39;ESTADOS&#39;, &#39;REGIAO&#39;, &#39;COD_UF&#39;, &#39;UF&#39;, &#39;geometry&#39;], dtype=&#39;object&#39;) Olha que interessante! Para cada estado, h√° seu nome, a regi√£o a que pertence, sua Unidade da Federa√ß√£o (UF) e o c√≥digo desta UF. Agora que j√° sabemos como est√£o nossos dados, vamos voltar um pouco na coluna geometry. print(gdf[&quot;geometry&quot;].head(5)) ## 0 POLYGON ((-73.80098 -7.11145, -73.74084 -7.143... ## 1 MULTIPOLYGON (((-36.39119 -10.50082, -36.39864... ## 2 MULTIPOLYGON (((-51.37380 -0.37053, -51.37337 ... ## 3 POLYGON ((-73.80098 -7.11145, -73.80106 -7.111... ## 4 MULTIPOLYGON (((-46.32975 -13.25248, -46.33072... ## Name: geometry, dtype: geometry Entenda, a geometria escolhida para representar cada um dos estados do Brasil foi o poligono, e isto √© poss√≠vel de visualizar na coluna geometry. Outro fato importante sobre esta coluna √© que, ela n√£o precisa ter este nome, ele √© definido automaticamente pelo GeoPandas para que as coisas sejam padronizadas e fiquem mais simples, mas, caso eu queira alterar, posso fazer isto facilmente da seguinte forma. gdf = gdf.rename_geometry(&quot;geometria&quot;) Ao fazer isto, vamos visualizar as colunas do GeoDataFrame alterado. print(gdf.columns) ## Index([&#39;ESTADOS&#39;, &#39;REGIAO&#39;, &#39;COD_UF&#39;, &#39;UF&#39;, &#39;geometria&#39;], dtype=&#39;object&#39;) Mas, e se nos dados que eu estiver carregando existirem mais de uma coluna de representa√ß√µes espaciais, como o GeoPandas entende qual deve ser utilizada? Bem, por padr√£o ele escolhera a primeira delas e a tratar√° como a coluna geometry do conjunto de dados, por√©m se eu quiser fazer a altera√ß√£o, tamb√©m √© poss√≠vel. Primeiro, vamos aprender a identificar como o GeoPandas mostra a coluna que ele est√° utilizando como padr√£o, para isto o atributo geometry √© utilizado. print(gdf.geometry.head(5)) ## 0 POLYGON ((-73.80098 -7.11145, -73.74084 -7.143... ## 1 MULTIPOLYGON (((-36.39119 -10.50082, -36.39864... ## 2 MULTIPOLYGON (((-51.37380 -0.37053, -51.37337 ... ## 3 POLYGON ((-73.80098 -7.11145, -73.80106 -7.111... ## 4 MULTIPOLYGON (((-46.32975 -13.25248, -46.33072... ## Name: geometria, dtype: geometry Este atributo devolve os dados da coluna padr√£o de geometrias. Vamos ver qual √© o nome da coluna de onde ele retira tais dados. print(gdf.geometry.name) ## geometria O nome √© exatamente o mesmo da coluna que renomeamos! Vamos trocar esta coluna padr√£o, para fazer este teste, vou duplicar a coluna que cont√©m as geometrias, por√©m cada uma ter√° um nome. gdf[&quot;geometria_dois&quot;] = gdf[&quot;geometria&quot;] print(gdf.columns) ## Index([&#39;ESTADOS&#39;, &#39;REGIAO&#39;, &#39;COD_UF&#39;, &#39;UF&#39;, &#39;geometria&#39;, &#39;geometria_dois&#39;], dtype=&#39;object&#39;) Feito isto, vamos alterar a coluna padr√£o de geometrias gdf = gdf.set_geometry(&quot;geometria_dois&quot;) Ao visualizar o resultado, percebemos que a mudan√ßa foi realizada com sucesso. print(gdf.geometry.name) ## geometria_dois A diferen√ßa entre o m√©todo rename_geometry e set_geometry est√° no ponto em que, a set_geometry altera a coluna que est√° sendo considerada como padr√£o para geometrias, equanto a rename_geometry altera o nome da coluna padr√£o de geometrias. Por fim, vamos visualizar a disposi√ß√£o destes dados em uma figura, para isto, utilizamos o m√©todo plot. gdf.plot() O ponto a ser entendido do m√©todo plot √© que, ele utiliza a coluna de geometrias padr√£o para gerar a figura, ent√£o, caso haja alguma inconsist√™ncia neste coluna este m√©todo ter√° problemas. Esta l√≥gica se aplica a todos os outros m√©todos do GeoPandas que utilizam a representa√ß√£o espacial para fazer as opera√ß√µes. Vamos salvar os resultados em um arquivo shapefile, para isto, fa√ßamos a utiliza√ß√£o do m√©todo to_file. del gdf[&quot;geometria&quot;] # Removendo coluna extra de geometrias gdf.to_file(&#39;tmp/estados_do_brasil_editado.shp&#39;) N√£o deixe de consultar a documenta√ß√£o do Pandas e do GeoPandas, por conta das bibliotecas trabalharem juntas, muitos formas de dados podem ser escritos e tratados, no GeoPandas √© poss√≠vel at√© mesmo ler dados diretamente de um banco de dados espacial (PostGres com PostGIS). 3.2.3 Manipula√ß√£o geom√©trica O GeoPandas oferece diferentes m√©todos para a manipula√ß√£o dos dados espaciais carregados, esta se√ß√£o far√° a apresenta√ß√£o de alguns destes m√©todos. √â importante lembrar que, todos estes m√©todos est√£o orientados a coluna de geometria padr√£o, vista na subse√ß√£o anterior. As opera√ß√µes apresentadas nas subse√ß√µes a seguir, s√£o representadas por m√©todos e atributos das GeoSeries e dos GeoDataFrames. 3.2.3.1 area Vamos come√ßar com as opera√ß√µes de √°rea, que de forma an√°loga ao nome, c√°lcula a √°rea da geometria em quest√£o. Vejamos a Figura abaixo que faz uma representa√ß√£o desta opera√ß√£o em diferentes formas geom√©tricas. O resultado da opera√ß√£o, devolve o c√°lculo da √°rea, representado em vermelho na Figura acima. Para exemplificar, vamos utilizar o conjunto de dados dos estados do Brasil estados_do_brasil = gpd.read_file(&quot;../data/1_estados_do_brasil_shape/Brasil.shp&quot;) Lembre-se, este conjunto de dados est√° dispon√≠vel no reposit√≥rio do curso Depois de carregar os dados, vamos utilizar o atributo area, que realiza a opera√ß√£o e devolve a √†rea para cada uma das linhas do conjunto de dados print(estados_do_brasil.area.head(5)) # Exibindo somente as 5 primeiras ## 0 12.553132 ## 1 2.285972 ## 2 11.424936 ## 3 128.108383 ## 4 46.911114 ## dtype: float64 A √°rea √© devolvida na unidade de medida da proje√ß√£o espacial utilizada no conjunto de dados, estes detalhes ser√£o apresentados nas se√ß√µes seguintes. 3.2.3.2 bounds O atributo bounds devolve as coordenadas m√≠nimas e m√°ximas da regi√£o coberta pela geometria. Sua representa√ß√£o √© feita na Figura abaixo. Perceba que, para cada figura √© criado um ret√¢ngulo que a envolve (Tamb√©m chamado de ret√¢ngulo envolvente) e as coordenadas m√≠nimas e m√°ximas s√£o retiradas desses. Vejamos um exemplo print(estados_do_brasil.bounds.head(5)) ## minx miny maxx maxy ## 0 -73.990943 -11.144489 -66.619331 -7.111453 ## 1 -38.237442 -10.500822 -35.151669 -8.812208 ## 2 -54.875779 -1.235830 -49.875779 4.437122 ## 3 -73.801055 -9.814097 -56.097385 2.247063 ## 4 -46.629029 -18.349041 -37.339928 -8.532272 3.2.3.3 centroid O atributo centroid devolve o ponto central da geometria. Sua representa√ß√£o √© feita na Figura abaixo. O ponto retornado para cada geometria √© apresentado em vermelho. Vejamos um exemplo com o GeoPandas. centroids_dos_estados = estados_do_brasil.centroid Se olharmos para o resultado teremos uma GeoSeries com um ponto para cada um dos estados, vamos visualizar estes pontos rapidamente. centroids_dos_estados.plot() Para fazermos um pequeno experimento, famos pegar a figura com os estados e fazer seu plot junto com os centroids. base = estados_do_brasil.plot() centroids_dos_estados.plot(ax=base, marker=&quot;o&quot;, color=&quot;red&quot;) 3.2.3.4 buffer O m√©todo buffer cria um circulo entorno de um ponto, e pode ser aplicado em diferentes tipos de an√°lises espaciais. Sua representa√ß√£o √© feita na Figura abaixo. Para testar esta opera√ß√£o, vamos utilizar os centroids extra√≠dos na se√ß√£o anterior. buffers = centroids_dos_estados.buffer(2) Da mesma forma que outros m√©todos que trabalham com dist√¢ncias, os valores dependem diretamente das proje√ß√µes espaciais utilizadas. Vamos fazer um plot do resultado gerado sob o mapa dos estados do Brasil. base = estados_do_brasil.plot() base = buffers.plot(ax = base, color = &#39;yellow&#39;) # Adicionando os centroids tamb√©m, para testar =D centroids_dos_estados.plot(ax = base, color = &#39;red&#39;) 3.2.3.5 envelope Por fim, o m√©todo envelope cria o mesmo ret√¢ngulo envolve utilizado no atributo bounds, com a diferen√ßa que, neste caso a geometria √© devolvida. A representa√ß√£o desta opera√ß√£o √© feita na Figura abaixo. Para testar, vamos pegar os buffers gerados anteriormente e ent√£o gerar seu ret√¢ngulo envolvente. envelopes = buffers.envelope Da mesma forma que nos demais, vamos visualizar o resultado. base = estados_do_brasil.plot() envelopes.plot(ax = base, color = &#39;green&#39;) 3.2.4 Sele√ß√£o e filtro de dados O GeoPandas ainda fornece m√©todos para a sele√ß√£o e filtros de dados baseados na posi√ß√£o espacial. Nesta se√ß√£o veremos dois desses, que podem ser muito √∫teis nas mais diversas an√°lises. 3.2.4.1 distance Vamos come√ßar com o m√©todo distance, que calcula a dist√¢ncia entre duas geometrias. Sua opera√ß√£o √© representada na Figura abaixo. Para testar esta opera√ß√£o, vamos carregar dois dados vetoriais, cada um represetando um estado do Brasil. estado_maranhao = gpd.read_file(&quot;../data/2_estado_sp_shape/shape_estado-sp.shp&quot;) estado_saopaulo = gpd.read_file(&quot;../data/3_estado_ma_shape/shape_estado-ma.shp&quot;) Vamos visualizar os dois juntos. Nesta visualiza√ß√£o, para ela ter sentido, abaixo dos estados foi fazer o plot do mapa do Brasil. base = estados_do_brasil.plot() base = estado_maranhao.plot(ax = base, color = &#39;green&#39;) estado_saopaulo.plot(ax = base, color = &#39;yellow&#39;) Certo, vamos calcular a dist√¢ncia entre cada um deles. distancia = estado_saopaulo.distance(estado_maranhao) print(distancia) ## 0 9.809695 ## dtype: float64 Feito, com isto tem-se a dist√¢ncia entre as duas geometrias, que neste caso representa os estados do Maranh√£o e S√£o Paulo. Esta mesma opera√ß√£o pode ser utilizada como uma forma de consulta aos dados, por exemplo, buscar estados que estejam a X de dist√¢ncia de outro. 3.2.4.2 contains O m√©todo contains verifica se uma geometria est√° contida em outra, sua representa√ß√£o visual √© apresentada abaixo . Vamos fazer um teste da opera√ß√£o com o estado do Amazonas, verificando se sua geometria est√° contida nas nos dados de estados do Brasil. Primeiro, vamos retirar do GeoDataFrame as informa√ß√µes do estado do Amazonas, para isto aplicaremos um filtro booleano, herdado do Pandas. estado_amazonas = estados_do_brasil[estados_do_brasil[&quot;ESTADOS&quot;] == &quot;Amazonas&quot;] # Indexa√ß√£o booleana Agora vamos verificar se o estado est√° contido em alguma geometria dos estados do Brasil. amazonas_esta_presente = estados_do_brasil.contains(estado_amazonas) print(amazonas_esta_presente.head(10)) ## 0 False ## 1 False ## 2 False ## 3 True ## 4 False ## 5 False ## 6 False ## 7 False ## 8 False ## 9 False ## dtype: bool Veja que em uma das linhas apareceu True, isto indica que a geometria do estado do Amazonas est√° contida nesta, que se formos olhar a linha do GeoDataFrame com os dados do estado, indica exatamente a linha do estado do Amazonas. print(estados_do_brasil[amazonas_esta_presente]) ## ESTADOS REGIAO COD_UF UF geometry ## 3 Amazonas Norte 13.0 AM POLYGON ((-73.80098 -7.11145, -73.80106 -7.111... 3.2.4.3 intersects Por fim, na parte de sele√ß√£o atrav√©s dos dados espaciais, vamos testar o m√©todo intersects, que verifica se uma geometria faz intersec√ß√£o com outra. Vale lembrar que, √© tido como uma intersec√ß√£o, quando um objeto cruza de alguma maneira, seu limite e seu interior com outro objeto. A opera√ß√£o pode ser vista abaixo. Para realizar este teste, vamos carregar um arquivo que cont√©m todos rios do nosso pa√≠s. E ent√£o verificar quais desses fazem intersec√ß√£o com o estado do Par√°. rios_brasil = gpd.read_file(&quot;../data/4_rios_brasil/Brasil_rios.shp&quot;) Antes de continuar, vamos visualizar os dados, junto aos estados do Brasil. base = estados_do_brasil.plot(color = &quot;gray&quot;) rios_brasil.plot(ax = base, color = &#39;red&#39;) base = estados_do_brasil.plot(color = &quot;gray&quot;) rios_brasil.plot(ax = base, color = &#39;red&#39;) plt.show() Agora vamos pegar somente o estado do Par√° do conjunto de estados e verificar quais rios fazem intersec√ß√£o com ele. estado_para = estados_do_brasil[estados_do_brasil[&quot;ESTADOS&quot;] == &quot;Par√°&quot;] rios_intersect_para = rios_brasil.intersects(estado_para) print(rios_intersect_para.head(5)) ## 0 False ## 1 False ## 2 False ## 3 False ## 4 False ## dtype: bool O resultado √© uma lista booleana, desta forma, vamos filtrar o conjunto de dados de rios com este √≠ndice, e ent√£o verificar quais deles fazem intersec√ß√£o com o estado do Par√°. rios_para = rios_brasil[rios_intersect_para] Com os dados separados, vamos fazer um plot para melhor visualizar o resultado. Neste plot vamos utilizar o matplotlib, para criar v√°rios subplots. import matplotlib.pyplot as plt # Criando figura e os subplots fig, (ax1, ax2) = plt.subplots(ncols=2) base = estados_do_brasil.plot(ax = ax1, color = &#39;blue&#39;) rios_para.plot(ax = base, color = &#39;red&#39;) base = estado_para.plot(ax = ax2, color = &#39;gray&#39;) rios_para.plot(ax = base, color = &#39;red&#39;) plt.show() Veja que esta opera√ß√£o verificou somente aqueles que fazem intersec√ß√£o com as fronteiras, n√£o indicando que est√° contido ou pr√≥ximo ao estado. 3.2.5 Manipula√ß√£o de proje√ß√µes Uma opera√ß√£o muito importante quando se est√° trabalhando dados espaciais √© a manipula√ß√£o de suas proje√ß√µes, estas que como explicado no cap√≠tulo anterior, fazem as representa√ß√µes das geometrias no espa√ßo, o GeoPandas fornece um m√©todo muito simples para tal opera√ß√£o, o to_crs, que altera a proje√ß√£o dos dados sem grandes problemas. Este foi o cap√≠tulo sobre GeoPandas e suas facilidades de uso üåü, n√£o deixe de consultar a documenta√ß√£o oficial e fazer seus testes üí´. "],
["introducao-ao-postgis.html", "4 Introdu√ß√£o ao postgis üêò 4.1 Instala√ß√£o 4.2 Um pouco de SQL", " 4 Introdu√ß√£o ao postgis üêò Uma das principais caracter√≠sticas que diferenciam os bancos de dados geogr√°ficos dos demais bancos de dados convencionais, √© a presen√ßa de uma coluna com a finalidade de armazenar uma propriedade geogr√°fica do registro. Al√©m disso , os bancos de dados geogr√°ficos tamb√©m devem oferecer de forma otimizada suporte √† opera√ß√µes espaciais. Diferente de um passado n√£o muito distante, atualmente existem muitas alternativas de bancos de dados geogr√°ficos, como: SQL Server Spatial, ESRI ArcSDE, Oracle Spatial, GeoMesa, PostGIS, etc. Cada uma destas op√ß√µes tem o objetivo em comum trabalhar com dados geogr√°ficos e todas est√£o sendo muito utlizadas em diversos segmentos nos dias de hoje, sendo o PostGIS a mais popular de todas. O PostGIS √© uma extens√£o geogr√°fica open source para o SGDB (Sistema Gerenciador de Banco de Dados) PostgreSQL, lan√ßada em 2001 inicialmente por uma empresa canadense chamada Refractions Research. O PostGIS segue a padroniza√ß√£o estabelecida pelo OGC (Open GIS Consortium), que prov√™ suporte para todos os objetos e fun√ß√µes da especifica√ß√£o SFS (Simple Features for SQL). De forma concisa, a especifica√ß√£o SFS foi criada pelo OGC (cons√≥rcio formado por empresas, universidades, etc) e trata das quest√µes de representa√ß√£o da componente espacial e vetorial dos dados geogr√°ficos, garantindo assim, a interoperabilidade entre os sistemas os utilizam. Este cap√≠tulo tem como objetivo introduzir ao leitor √† extens√£o espacial PostGIS . Ao final, o leitor dever√° est√° apto a configurar corretamente o ambiente para a utiliza√ß√£o da ferramente, carregar arquivos vetoriais e realizar opera√ß√µes espaciais. 4.1 Instala√ß√£o Como o PostGIS √© uma extens√£o do PostgreSQL, primeiramente dever√° ser feita a instala√ß√£o do SGBD. Importante: N√£o esque√ßa o nome de usu√°rio e senha que voc√™ definir durante a instala√ß√£o, pois essas informa√ß√µes ser√£o de suma import√¢ncia, anote se necess√°rio. A vers√£o do PostgreSQL utilizada aqui √© ser√° a 11.5. A instala√ß√£o do PostgreSQL e PostGIS no sistema operacional windows, pode ser feita atrav√©s do instalador dispon√≠vel nesse link, para isso fique atento durante a instala√ß√£o e na segunda tela do assistente, no item Spatial Extensions marque a op√ß√£o PostGIS. A instala√ß√£o do PostgreSQL e PostGIS no sistema Operacional MacOS pode ser feita atrav√©s do gerenciador de pacotes brew, utilizado os seguintes comandos: brew install postgres brew install postgis Para a instala√ß√£o nos sistemas operacionais linux, utilize os seguintes comandos : sudo apt install postgresql postgresql-contrib sudo apt-get install postgis Para verificar se a instala√ß√£o do PostgreSQL foi realizada corretamente, abra o terminal e digite o seguinte comando: psql --version Se tudo ocorreu bem, dever√° aparecer uma sa√≠da com a vers√£o do PostgreSQL, algo parecido com psql (PostgreSQL) 11.5. Para verificar a instala√ß√£o do PostGIS, abra o terminal e execute o seguinte comando para abrir o interpretador do PostgreSQL: sudo -u &lt;user&gt; psql Obs: Substitua o trecho &lt;user&gt; para o usu√°rio do PostgreSQL definido na instala√ß√£o. Com o terminal do PostgreSQL aberto, execute o seguinte comando para verificar a vers√£o do PostGIS: SELECT PostGIS_version(); Se tudo estiver certo, dever√° aparecer como sa√≠da a vers√£o do PostGIS. Para sair do interpretador psql, basta executar o comando \\q. E com isso finalizamos as configura√ß√£o iniciais necess√°rias iniciar os trabalhos com o PostGIS. Para mais informa√ß√µes, consulte a p√°gina oficial do PostGIS em: https://postgis.net/install. Na pr√≥xima se√ß√£o iremos criar um banco de dados novo e habilitar nele a extens√£o espacial PostGIS, para que possam ser executadas as nossas primeiras consultas espaciais. 4.2 Um pouco de SQL SQL (Structured Query Language) √© linguagem padr√£o de consultas declarativas dos bancos de dados relacionais. Ela foi concebida na d√©cada de 1970, como resultado de um estudo feito por Edgar Frank Codd, que na √©poca era funcion√°rio da IBM, e prop√¥s o modelo de banco de dados relacional (Codd 1970) que em sua ess√™ncia √© utilizado at√© os dias de hoje. Como dito anteriormente, o PostGIS √© uma extens√£o espacial que funciona sobre o SGBD PosgreSQL, que utiliza o modelo de banco de dados relacional. Sendo assim, antes de iniciarmos de fato as consultas espaciais como o PostGIS, iremos executar alguns comandos SQL b√°sicos para prepara√ß√£o do ambiente. 4.2.1 Acessando a interface PostgreSQL O psql √© uma interface padr√£o que funciona por linha de comando, e permite interagir rapidamente com o PostgreSQL. Como o foco deste material √© a apenas apresentar alguns recursos do PostGIS, iremos executar as consultas SQL usando o psql, o que n√£o √© muito recomendado se trabalhar com esquemas mais complexos de bancos de dados, para isso, podem ser utilizado outras interfaces mais agrad√°vies e eficienes como o pgAdmin. Para acessar o psql execute o comando abaixo, substituindo o trecho &lt;user&gt;, pelo nome de usu√°rio postgres que foi definido durante a instala√ß√£o: sudo -u &lt;user&gt; psql Ao ser solicitado a senha, digite a senha de administrador do seu sistema operacional. O psql possui algumas utilit√°rio para o geraciomento do PostgreSQL, use o comando \\l para listar todos os bancos de dados dispon√≠veis, em sua m√°quina. Algo parecido com o que mostrado na Figura 4.1 dever√° aparecer. Figure 4.1: Listando todos os banco de dados atrav√©s do psql. Normalmente, a instala√ß√£o padr√£o do PostgreSQL cria algumas bases de dados. A seguir, iremos utilizar comandos SQL para criar um novo banco de dados e tamb√©m adicionar a extens√£o espacial do PostGIS. 4.2.2 Criando uma nova base de dados A linguagem SQL √© organizada em alguns subconjuntos, cada um deles com comando espec√≠ficos para determinadas tarefas. A Figura 4.2 mostra a os subconjuntos que comp√µe a linguagem SQL. Figure 4.2: Listando todos os banco de dados atrav√©s do psql. DDL - Data Definition Laguage (Linguagem de Defini√ß√£o de Dados): √â o subconjunto de instru√ß√µes da linguagem SQL respons√°vel por manipular diretamente o esquema do banco de dados e estrura das tabelas. DML - Data Manipulation Language (Linguagem de Manipula√ß√£o de Dados): √â o subconjunto de instru√ß√µes da linguagem SQL respons√°vel por interagir diretamente com os dados das tabelas. DCL - Data Control Language (Linguagem de Controle de Dados): √â o subconjunto de instru√ß√µes da linguagem SQL respons√°vel por administrar a seguran√ßa das bases de dados, adicionando ou removendo permiss√µes. TCL - Transaction Control Language (Linguagem de Controle de Transa√ß√£o): √â o subconjunto de instru√ß√µes da linguagem SQL respons√°vel por gerenciar as transa√ß√µes das consultas SQL. Neste material, o escopo abordado ser√° apenas alguns comando do subconjunto DDL e DML. Para mais informa√ß√µes a respeito do gerenciamento de banco de dados e a organiza√ß√£o da linguagem SQL, recomenda-se a leitura do trabalho de (Kumar, Raheja, and Sachdeva 2012), o qual aborada com mais aprofundamento estes t√≥picos. Agora iremos criar um banco de dados para trabalharmos com os recursos espacias do PostGIS, para isso execute o comando a seguir: CREATE DATABASE dbgeo; O comando acima cria um novo banco de dados chamado dbgeo. Caso queira o criar um banco de dados com o nome diferente, utilize o mesmo comando substituindo o trecho dbgeo pelo nome desejado. Ap√≥s receber a mensagem de confirma√ß√£o, ser√° necess√°rio mudar o interpretador psql para o novo banco de dados criado, para isso utilize o seguinte comando: \\l dbgeo; Note que o trecho dbgeo √© o nome da base de dados que foi criada no passo anterior. Se tudo estiver ocorrido bem, dever√° aparecer a confirma√ß√£o conforme a Figura 4.3. Figure 4.3: Criando e alterando base dados. Por fim, para habilitarmos a nova base de dados para suportar opera√ß√µes com dados espaciais, iremos adicionar a extens√£o PostGIS. Para isso, execute o seguinte comando: CREATE EXTENSION postgis; Ap√≥s adicionarmos a extens√£o PostGIS em nosso banco de dados, vamos criar a nossa primeira tabela com atributos geom√©tricos. "],
["para-saber-mais.html", "5 Para saber mais üî≠ 5.1 IMPACTOS DA RESOLU√á√ÉO ESPACIAL DE MODELOS DIGITAIS DE SUPERF√çCIE NO C√ÅLCULO DA PERDA DE SOLO ATRAV√âS DA EUPS EM AMBIENTE URBANO 5.2 CRIA√á√ÉO E AVALIA√á√ÉO DE MAPAS DE SUSCETIBILIDADE A INUNDA√á√ÉO PARA O MUNIC√çPIO DE IGUAPE, ESTADO DE S√ÉO PAULO 5.3 CONECTIVIDADE DEMOGR√ÅFICA E ACLIMATA√á√ÉO DE PEIXES RECIFAIS DO G√äNERO SPARISOMA EM CEN√ÅRIO DE MUDAN√áAS CLIM√ÅTICAS 5.4 PARAMETRIZA√á√ÉO DE ALGORITMOS EMP√çRICOS E ALGORITMO QUASI-ANAL√çTICO QAA PARA ESTIMATIVA DE CLOROFILA-A EM LAGOS DA V√ÅRZEA DO RIO AMAZONAS 5.5 QUANTIFICA√á√ÉO REMOTA DA CONCENTRA√á√ÉO DE S√ìLIDOS TOTAIS E INORG√ÇNICOS EM SUSPENS√ÉO EM LAGOS DA PLAN√çCIE DE INUNDA√á√ÉO DO BAIXO AMAZONAS - UMA ABORDAGEM MULTI-SENSOR", " 5 Para saber mais üî≠ A seguir s√£o apresentados alguns estudos desenvolvidos no INPE. 5.1 IMPACTOS DA RESOLU√á√ÉO ESPACIAL DE MODELOS DIGITAIS DE SUPERF√çCIE NO C√ÅLCULO DA PERDA DE SOLO ATRAV√âS DA EUPS EM AMBIENTE URBANO No presente estudo foram comparados os resultados da aplica√ß√£o da Equa√ß√£o Universal de Perdas de Solo (EUPS) com o uso de modelos digitais de terreno obtidos atrav√©s de cartas topogr√°ficas na escala 1:10.000 integradas com coleta de pontos por GPS; e tamb√©m pelo levantamento de um modelo digital de superf√≠cie (MDS) por VANT. Os resultados obtidos com os dois m√©todos foram ainda comparados com uma estimativa de movimenta√ß√£o de solo pela inser√ß√£o de estacas no terreno, com monitoramento de um ano. Figure 5.1: Mapa de Londres com √≥bitos por c√≥lera (pontos) e po√ßos de √°gua (cruzetas) Figura 5.1 - Estimativa da perda de solo anual derivado de carta topogr√°fica e pontos GPS; derivado de levantamento com VANT; e interpola√ß√£o da perda de solo monitorada por estacas. Artigo completo: Simp√≥sio Brasileiro de Sensoriamento Remoto - SBSR 5.2 CRIA√á√ÉO E AVALIA√á√ÉO DE MAPAS DE SUSCETIBILIDADE A INUNDA√á√ÉO PARA O MUNIC√çPIO DE IGUAPE, ESTADO DE S√ÉO PAULO As inunda√ß√µes s√£o os desastres naturais mais frequentes e que causam maiores danos econ√¥micos, sociais e ambientais no mundo. Para este trabalho, entende-se inunda√ß√£o como a eleva√ß√£o do n√≠vel de √°gua de um corpo h√≠drico para al√©m do seu n√≠vel normal, alagando a plan√≠cie aluvial deste corpo. As inunda√ß√µes s√£o causadas devido √†s caracter√≠sticas ambientais tais como chuvas, formato da bacia hidrogr√°fica, cobertura vegetal, escoamento superficial; e antr√≥picas; como a impermeabiliza√ß√£o dos solos e o descarte de lixo em locais inadequados. Para tomar medidas preventivas e planejar poss√≠veis remedia√ß√µes, torna se necess√°rio identificar as √°reas do munic√≠pio com maior ou menor possibilidade de inunda√ß√£o. Mapas de suscetibilidade se apresentam como ferramentas fundamentais neste tipo de planejamento. Diferentes m√©todos podem ser utilizados para elaborar os mapas, trazendo resultados mais ou menos veross√≠meis. Este trabalho buscou identificar as diferen√ßas ao aplicar o mesmo m√©todo de an√°lise de dados em modelos digitais de eleva√ß√£o diferentes, sendo um destes fornecido pelo TopoData (BRASIL, 2011), elaborado a partir de imagens do SRTM (Shuttle Radar Topography Mission), e de um modelo digital de eleva√ß√£o em grade elaborado a partir de curvas de n√≠vel dispon√≠veis no Sistema de Informa√ß√µes Geogr√°ficas do Ribeira de Iguape e Litoral Sul (SIGRB). Pretendeu se assim analisar o impacto de m√©todos diferentes ao se representar uma mesma √°rea. Figure 5.2: Mapa de Londres com √≥bitos por c√≥lera (pontos) e po√ßos de √°gua (cruzetas) Figura 5.2 - Suscetibilidade √† inunda√ß√£o para o munic√≠pio de Iguape ‚Äì SP utilizando curvas de n√≠vel (esquerda) e SRTM (direita) como dado topogr√°fico. Artigo completo: Revista Gest√£o &amp; Sustentabilidade Ambiental 5.3 CONECTIVIDADE DEMOGR√ÅFICA E ACLIMATA√á√ÉO DE PEIXES RECIFAIS DO G√äNERO SPARISOMA EM CEN√ÅRIO DE MUDAN√áAS CLIM√ÅTICAS As mudan√ßas na circula√ß√£o e na temperatura do oceano afetam diretamente a capacidade de dispers√£o e assentamento dos organismos marinhos. Esta influ√™ncia se d√° principalmente nas condi√ß√µes de sobreviv√™ncia dos ovos e larvas, assim como na trajet√≥ria imposta pela circula√ß√£o superficial. As proje√ß√µes de cen√°rios futuros de mudan√ßas clim√°ticas podem resultar em altera√ß√µes na circula√ß√£o e temperatura dos oceanos, afetando o ciclo de vida dos organismos marinhos. O objetivo deste trabalho foi determinar os padr√µes de conectividade demogr√°fica das popula√ß√µes de peixes recifais do g√™nero Sparisoma sp. das ilhas oce√¢nicas e plataforma continental do Brasil localizadas em Unidades de Conserva√ß√£o Marinhas (UCMs), frente √†s poss√≠veis altera√ß√µes ambientais em cen√°rios futuros de mudan√ßas clim√°ticas. Figure 5.3: Mapa de Londres com √≥bitos por c√≥lera (pontos) e po√ßos de √°gua (cruzetas) Figura 5.3 - Padr√µes de dispers√£o de ovos e larvas de Ichthyop para os ver√µes das simula√ß√µes hor√°rias nos cen√°rios de aclimata√ß√£o. Onde: SPSP ‚Äì Arquip√©lago de S√£o Pedro e S√£o Paulo; ML ‚Äì Parcel Manuel Lu√≠z; CC ‚Äì Costa dos Corais; AB ‚Äì Abrolhos; AR ‚Äì Atol das Rocas; FN ‚Äì Fernando de Noronha; CF ‚Äì Cabo Frio; RC ‚Äì Recife de Corais; TR ‚Äì Ilhas de Trindade e Martim Vaz. Observou-se que para o final do s√©culo XXI, o cen√°rio de mudan√ßas clim√°ticas (RCP 8.5), apresenta aumento da mortalidade e redu√ß√£o da conectividade entre as Unidades de Conserva√ß√£o Marinhas pr√≥ximas ao equador. A condi√ß√£o de aclimata√ß√£o frente a um oceano mais quente, reduz significativamente a mortalidade e consequentemente, aumenta a conectividade entre as UCMs, principalmente no ver√£o. Disserta√ß√£o completa: Instituto Nacional de Pesquisas Espaciais (INPE) 5.4 PARAMETRIZA√á√ÉO DE ALGORITMOS EMP√çRICOS E ALGORITMO QUASI-ANAL√çTICO QAA PARA ESTIMATIVA DE CLOROFILA-A EM LAGOS DA V√ÅRZEA DO RIO AMAZONAS O monitoramento sistem√°tico, essencial para a manuten√ß√£o dos servi√ßos ecossist√™micos, visa auxiliar na gest√£o, manuten√ß√£o e recupera√ß√£o de recursos h√≠dricos diante das a√ß√µes antr√≥pica. Suplementando as metodologias tradicionais, o sensoriamento remoto (SR) de ambientes aqu√°ticos relaciona as propriedades √≥pticas e biogequ√≠micas do meio, possibilitando uma vis√£o sin√≥ptica de seus padr√µes de distribui√ß√£o no tempo e espa√ßo. A determina√ß√£o do estado tr√≥fico e da produtividade prim√°ria do ambiente, estimadas por meioda concentra√ß√£o de clorofila-a (Chl-a). podem ser utilizados como √≠ndice da qualidade do recurso h√≠drico. A quantifica√ß√£o de Chl-a por SR embasa-se na aplica√ß√£o emp√≠rica e/ou semi-anal√≠tica de algoritmos, geralmente desenvolvidos para √°guas oce√¢nicas e costeiras, necessitando assim serem calibrados para sua utiliza√ß√£o em √°guas continentais complexas como √†s da plan√≠cie de inunda√ß√£o amaz√¥nica. Portanto este trabalho teve como objetivo Estimar a concentra√ß√£o de Chl-a em √°guas t√∫rbidas de lagos amaz√¥nicos a partir da parametriza√ß√£o de algoritmos bi√≥ticos (emp√≠ricos e semi-anal√≠ticos) utilizando dados in situ e posterior valida√ß√£o e espacializa√ß√£o com sua aplica√ß√£o a imagens de sat√©lite de m√©dia/alta resolu√ß√£o atualmente dispon√≠veis, OLI/Landsat-8, MSI/Sentinel-2 e OLCI/Sentinel-3. Figure 5.4: Algoritmos calibrados com dados in situ especializados para o sensor MSI. Sendo os algoritmos: a) NDCI (linear), b) NDCI (quadr√°tico), c) 2B-M (linear), d) 3B-M (linear). Disserta√ß√£o completa: Instituto Nacional de Pesquisas Espaciais (INPE) 5.5 QUANTIFICA√á√ÉO REMOTA DA CONCENTRA√á√ÉO DE S√ìLIDOS TOTAIS E INORG√ÇNICOS EM SUSPENS√ÉO EM LAGOS DA PLAN√çCIE DE INUNDA√á√ÉO DO BAIXO AMAZONAS - UMA ABORDAGEM MULTI-SENSOR A utiliza√ß√£o de imagens de sensoriamento remoto √© de fundamental import√¢ncia para aumentar o conhecimento sobre a din√¢mica da troca de sedimentos entre o Rio Amazonas e as plan√≠cies de inunda√ß√£o j√° que ela pode ajudar a entender como as mudan√ßas clim√°ticas e de uso da terra influenciam esse processo. Neste sentido, este trabalho investigou a acur√°cia de algoritmos de estimativa de TSS (Total de S√≥lidos em Suspens√£o) e TSI (Total de S√≥lidos Inorg√¢nicos em suspens√£o) atrav√©s da utiliza√ß√£o de tr√™s sensores de m√©dia resolu√ß√£o espacial (Landsat-8/OLI, Sentinel-2A/MSI e CBERS-4/WFI) em lagos na plan√≠cie de inunda√ß√£o do Baixo Amazonas. Atrav√©s de simula√ß√£o Monte Carlo, foram calibrados e validados algoritmos. Figure 5.5: Mapa de TSI obtidos pelos sensores MSI, OLI e WFI atrav√©s dos algoritmos emp√≠ricos que apresentaram os melhores resultados. Disserta√ß√£o completa: Instituto Nacional de Pesquisas Espaciais (INPE) "],
["references.html", "6 References", " 6 References "]
]
