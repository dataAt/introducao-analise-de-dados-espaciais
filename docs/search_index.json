[
["introdu√ß√£o.html", "1 Introdu√ß√£o", " 1 Introdu√ß√£o "],
["introdu√ß√£o-ao-r.html", "2 Introdu√ß√£o ao R üíé", " 2 Introdu√ß√£o ao R üíé "],
["python.html", "3 Python ‚ú® 3.1 Pandas üêº 3.2 GeoPandas üåêüêº", " 3 Python ‚ú® Python √© uma linguagem de programa√ß√£o vers√°til, multiparadigma, que permite aos desenvolvedores criar r√°pidas solu√ß√µes para seus problemas sem grandes preocupa√ß√µes com a sintaxe e formas de uso da linguagem. Tais caracter√≠sticas fizem Python alcan√ßar os mais variados nichos de aplica√ß√£o. Por ser uma linguagem geral para atingir tais nichos, foram criadas pela comunidade de Python diversas bibliotecas, todas seguindo a ideia da simplicidade de aplica√ß√£o e prototipa√ß√£o da linguagem. √â neste contexto que surge o GeoPandas, que fornece extens√µes de uso espacial para uma biblioteca de an√°lise de dados muito conhecida na comunidade Python, o Pandas. Desta forma, este cap√≠tulo busca explicar as principais formas de utiliza√ß√£o do GeoPandas. Por ser baseada no Pandas, h√° uma pequena se√ß√£o que trata sobre o uso b√°sico da linguagem, mas √© recomendado que o leitor tamb√©m conhe√ßa tal biblioteca, para isto, existe o curso de introdu√ß√£o √† an√°lise de dados, que explica os principais conceitos de utiliza√ß√£o do Pandas, n√£o deixe de conferir! 3.1 Pandas üêº Com a necessidade de facilitar todo o processo de an√°lise de dados, atrav√©s de uma linguagem simples e amig√°vel, a comunidade Python criou o Pandas, uma biblioteca que disponibiliza m√©todos de alto n√≠vel para a manipula√ß√£o, processamento e an√°lise dos mais variados tipos de dados. Atrav√©s dos m√©todos desta biblioteca √© poss√≠vel aplicar todo o ciclo de an√°lise de dados, este indo desde a coleta at√© o processamento e an√°lise. Para realizar tais atividades, o pandas disponibiliza diversas estruturas de dados, sendo as Series e os DataFrames as principais. Cada uma dessas estruturas de dados, trata especificamente de uma forma de realizar a abstra√ß√£o do formato dos dados em c√≥digo, isto faz com que seja necess√°rio o entendimento das principais diferentes entre cada uma delas, para que seja poss√≠vel realizar sua correta aplica√ß√£o. Vamos buscar comparar cada uma dessas estruturas para entender suas diferen√ßas. As Series s√£o estruturas de dados unidimensionais, possuindo apenas uma dimens√£o que pode ser manipulada, tal dimens√£o sendo chamada de √≠ndice. J√° os DataFrames apresentam duas dimens√µes para a manipula√ß√£o. Estas caracter√≠sticas, na pr√°tica, indicam que, as Series apenas representar vetores, enquanto os DataFrames podem representar matrizes de N-Dimens√µes. Para esta ideia ficar clara, vejamos a Figura abaixo. Perceba que, as Series possuem o campo para o armazenamento dos dados (Representado em Azul), e o √≠ndice (Representado em roxo), n√£o podendendo ser adicionado nenhum outro campo, isto faz com que, todos os dados tenham de ser armazenados em apenas uma coluna, em v√°rias linhas. Para o DataFrame o cen√°rio apresentado na Figura √© diferente, al√©m dos √≠ndices, h√° tamb√©m as colunas (Representada em vermelho), o que permite que dentro desta estrutura existam n√£o s√≥ um conjunto de linhas, como as Series mas sim um conjunto de colunas, onde cada uma dessas possuem v√°rias linhas. Na pr√°tica o que fica subentendido √© que, os DataFrames s√£o um conjunto de Series. Isto ocorre j√° que, cada uma das colunas criadas dentro do DataFrame s√£o Series, o que acaba gerando um efeito muito interessante na API do Pandas, boa parte dos m√©todos dispon√≠veis para as Series tamb√©m est√£o presentes nos DataFrames. Vamos ver alguns exemplos em c√≥digo para fixar a diferen√ßa entre essas duas estruturas de dados. 3.1.1 Manipula√ß√£o de dados Vamos come√ßar criando uma Series. import pandas as pd sr = pd.Series([1, 2, 3, 4, 5]) Pronto! Acabamos de criar uma Series com uma lista de valores, vejamos como ela est√° sendo representada. print(sr) ## 0 1 ## 1 2 ## 2 3 ## 3 4 ## 4 5 ## dtype: int64 A representa√ß√£o est√° da mesma forma que vimos antes. Vamos agora fazer uma pequena manipula√ß√£o dos dados, para isto, utilizaremos os m√©todos loc e iloc dispon√≠veis dentro do objeto Series gerado, onde o m√©todo loc busca o √≠ndice com o nome inserido e o iloc busca o √≠ndice com a posi√ß√£o inserida. A assinatura de cada um dos m√©todos est√° descrita abaixo. Lembre-se que este m√©todo est√° presente tanto na classe Series como na classe DataFrame. DataFrame Series .loc[linha, coluna] .loc[linha] .iloc[linha] .iloc[linha] Antes de fazermos o teste destes m√©todos, vamos alterar o √≠ndice da nossa Series. # Vamos visualizar o √≠ndice print(sr.index) ## RangeIndex(start=0, stop=5, step=1) O atributo index devolve os elementos que est√£o no √≠ndice, para fazer sua mudan√ßa, basta realizar uma atribui√ß√£o, veja. sr.index = [&quot;um&quot;, &quot;dois&quot;, &quot;tres&quot;, &quot;quatro&quot;, &quot;cinco&quot;] print(sr.index) ## Index([&#39;um&#39;, &#39;dois&#39;, &#39;tres&#39;, &#39;quatro&#39;, &#39;cinco&#39;], dtype=&#39;object&#39;) Fizemos esta mudan√ßa, para que cada um dos m√©todos loc e iloc seja mais simples de entender. Certo, vamos come√ßar buscando a linha que tenha o nome dois. print(sr.loc[&quot;dois&quot;]) ## 2 Agora vamos buscar a linha que est√° na posi√ß√£o dois. print(sr.iloc[1]) # Lembre-se, o Python come√ßa a contar no zero =D ## 2 Percebeu? Temos o mesmo resultado, muito interessante n√£o ? Al√©m disso ainda posso aplicar filtros sob os dados,utilizando o conceito de indexa√ß√£o booleana, onde atrav√©s de um vetor de VERDADEIRO e FALSO √© poss√≠vel selecionar as linhas. Vamos buscar somente os valores que s√£o acima de tr√™s. print(sr[sr &gt; 3]) ## quatro 4 ## cinco 5 ## dtype: int64 Dica: O que ocorre nesta parte √©, dentro das chaves de sr (sr[]) √© passado a express√£o sr &gt; 3 que devolve uma lista de verdadeiros e falsos, fazendo assim o filtro. Muito interessante! Mas at√© aqui trabalhamos com apenas uma dimens√£o, vamos tentar acrescentar mais, para isto, primeiro vamos criar uma matriz. matriz = [ [1, 2, 3], [4, 5, 6] ] A matriz criada √© representada por uma lista de listas. Vamos tentar criar uma Series com esta matriz. sr = pd.Series(matriz) print(sr) ## 0 [1, 2, 3] ## 1 [4, 5, 6] ## dtype: object Eita! Perceba que, em cada linha h√° uma lista de valores, o que √© ruim! J√° que a manipula√ß√£o fica dif√≠cil (Tenta fazer uma indexa√ß√£o booleana, vai falhar üò¢). Para este caso, existem os DataFrames! Vamos come√ßar criando um com a mesma matriz gerada anteriormente. df = pd.DataFrame(matriz) print(df) ## 0 1 2 ## 0 1 2 3 ## 1 4 5 6 Opa! Agora o cen√°rio √© outro, conseguimos colocar cada um dos valores em seu devido lugar. Perceba que a representa√ß√£o mudou bastante, aqui temos v√°rias colunas de dados, e mesmo assim, todos os m√©todos j√° apresentados at√© aqui funcionam. Vai l√°, tenta! Uma coisa importante sobre os DataFrames s√£o suas colunas, para acessar elas podemos fazer da seguinte forma. print(df[0]) ## 0 1 ## 1 4 ## Name: 0, dtype: int64 Viu! Estamos acessando a primeira coluna, se fizermos a mesma coisa, com a segunda tamb√©m vai funcionar (Tenta inserir o n√∫mero 1, para voc√™ ver o que acontece). Dica: Ao fazer df[0], estamos buscando o ‚Äúnome‚Äù da coluna, e n√£o sua posi√ß√£o Da mesma forma que eu podemos recuperar o √≠ndice com o atributo index podemos recuperar as colunas com o atributo columns print(df.columns) ## RangeIndex(start=0, stop=3, step=1) Para fazer a mudan√ßa dos nomes de cada coluna a mesma regra do index √© v√°lida. df.columns = [&quot;col1&quot;, &quot;col2&quot;, &quot;col3&quot;] print(df.columns) ## Index([&#39;col1&#39;, &#39;col2&#39;, &#39;col3&#39;], dtype=&#39;object&#39;) Vamos recuperar a primeira coluna novamente print(df[&quot;col1&quot;]) ## 0 1 ## 1 4 ## Name: col1, dtype: int64 Assim, fica mais f√°cil entender que, quando se trata de colunas, estamos buscando os nomes, e n√£o simplesmente as posi√ß√µes. Bom, agora que j√° entendemos toda a utiliza√ß√£o b√°sica do Pandas, vamos come√ßar a falar um pouco sobre o GeoPandas üíú 3.2 GeoPandas üåêüêº Com o entendimento do que √© a biblioteca Pandas, suas estruturas de dados e principais caracter√≠sticas, o estudo do GeoPandas pode ser iniciado. Mas o que √© o GeoPandas ? GeoPandas √© um projeto open-source que busca facilitar o trabalho com dados vetoriais em Python, para isto, tem como base as estruturas de dados do Pandas Desta forma, a ideia b√°sica por tr√°s do GeoPandas √© adicionar o suporte a manipula√ß√£o de dados espaciais as estruturas de dados do Pandas, e com isto prover formas de manipula√ß√£o simples e direta a tais dados. Para fazer isto, o GeoPandas utiliza estruturas de dados geom√©tricas implementadas pela biblioteca Shapely dentro das Series e dos DataFrames. Com esta adi√ß√£o, duas estruturas de dados surgem, as GeoSeries e os GeoDataFrames. Este conceito pode ser melhor entendido com a observa√ß√£o da Figura abaixo. Perceba que, h√° a mesma estrutura que foi apresentada na se√ß√£o anterior, com as geometrias sendo o diferencial nas estruturas de dados. Na pr√°tica o que ocorre √©, todas as formas de manipula√ß√£o geom√©tricas, que como citadas s√£o implementadas com o Shapely, s√£o implementadas em uma classe GeoPandasBase que √© extendida pelas GeoSeries e GeoDataFrames, da mesma forma, essas tamb√©m extendem as estruturas de dados equivalentes do Pandas, veja a Figura abaixo. Como a GeoSeries e os GeoDataFrames s√£o especializa√ß√µes diretas das Series e dos DataFrames as mesmas caracter√≠sticas s√£o mantidas, onde, respectivamente, um armazena apenas uma coluna de valores, tendo uma dimens√£o de manipula√ß√£o e o outro armazena diversas colunas com duas dimens√µes de manipula√ß√£o, da mesma forma como apresentado na se√ß√£o anterior. Para fixar o funcionamento de cada uma dessas estruturas, vamos fazer alguns testes com a API do GeoPandas. 3.2.1 GeoSeries e GeoDataFrames Para come√ßar os testes, vamos importar a biblioteca de geometrias, Shapely e o GeoPandas. import shapely import geopandas as gpd Agora, vamos criar uma GeoSeries. gsr = gpd.GeoSeries([ shapely.geometry.Point(1, 1) ]) Dica: A geometria criada n√£o possui qualquer tipo de refer√™ncia espacial, portanto representa apenas um ponto no plano cartesiano. Veja que acabamos de criar uma GeoSeries que armazena uma geometria de ponto, vamos visualizar o objeto criado. print(gsr) ## 0 POINT (1.00000 1.00000) ## dtype: geometry A forma √© exatamente a mesma de uma Series. Vamos criar um novo objeto com mais geometrias inseridas. gsr = gpd.GeoSeries([ shapely.geometry.Point(1, 1), shapely.geometry.Point(2, 2), shapely.geometry.Point(4, 3) ]) print(gsr) ## 0 POINT (1.00000 1.00000) ## 1 POINT (2.00000 2.00000) ## 2 POINT (4.00000 3.00000) ## dtype: geometry Caso eu queira visualizar n√£o s√≥ a tabela, mas sim a representa√ß√£o das geometrias criadas no espa√ßo, √© poss√≠vel utilizar o m√©todo plot. gsr.plot() Mas as GeoSeries podem ser limitadas em alguns casos, imagine que para a realiza√ß√£o de um estudo seja necess√°rio n√£o s√≥ a geolocaliza√ß√£o ou a representa√ß√£o geom√©trica no espa√ßo, mas tamb√©m caracter√≠sticas do ambiente, qualquer tipo de informa√ß√£o que n√£o a espacial. Nestes casos podemos utilizar os GeoDataFrames que al√©m de colunas de geometria permitem o armazenamento de outras informa√ß√µes, isto por permitir multiplas colunas. Vamos criar um para fazer testes. gdf = gpd.GeoDataFrame({ &#39;atributo_a&#39;: [10, 11, 12], &#39;geometria&#39;: [ shapely.geometry.Point(1, 1), shapely.geometry.Point(2, 2), shapely.geometry.Point(4, 3) ] }) Visualizando o resultado print(gdf) ## atributo_a geometria ## 0 10 POINT (1 1) ## 1 11 POINT (2 2) ## 2 12 POINT (4 3) Agora as geometrias passam a ser vinculadas com outros valores, o que pode ser muito √∫til em v√°rios cen√°rios. At√© aqui foram criadas geometrias sem nenhum tipo de liga√ß√£o com o mundo real, ent√£o, vamos agora trabalhar um pouco com dados que fa√ßam esta representa√ß√£o, para isto, vejamos como carregar dados espaciais com o GeoPandas. 3.2.2 Leitura e escrita de dados Al√©m de todas as caracter√≠sticas citadas at√© aqui, o GeoPandas ainda ajuda na leitura e na escrita de dados vetoriais, tudo seguindo o padr√£o de facilidade de uso do Pandas. Para realizar essas opera√ß√µes o GeoPandas utiliza como base a biblioteca Fiona, que traz suporte a leitura e escrita de uma enorme variedade de formatos vetoriais, sendo alguns deles: GeoJSON; GPSTrackMaker; ESRI Shapefile; FileGDB; OpenFileGDB. Al√©m destes formatos a biblioteca aceita v√°rios outros, para a lista completa de formatos suportados, consulte a documenta√ß√£o do Fiona. Para fazer alguns testes utilizando as funcionalidades de leitura dos dados, vamos carregar um dado vetorial, dos estados do Brasil que est√£o armazenados em um shapefile. gdf = gpd.read_file(&quot;../data/1_estados_do_brasil_shape/Brasil.shp&quot;) Estes dados est√£o dispon√≠veis no reposit√≥rio do curso. Com os dados carregados, vamos visualizar qual foi a estrutura gerada ao carregar os dados. print(type(gdf)) ## &lt;class &#39;geopandas.geodataframe.GeoDataFrame&#39;&gt; Um GeoDataFrame! Isto √© feito por padr√£o pela biblioteca, assim, independente do formato de entrada, o GeoPandas busca inserir os dados dentro de um GeoDataFrame. Certo, vamos olhar ent√£o o que est√° dentro deste objeto. print(gdf.head(5)) ## ESTADOS REGIAO ... UF geometry ## 0 Acre Norte ... AC POLYGON ((-73.80098 -7.11145, -73.74084 -7.143... ## 1 Alagoas Nordeste ... AL MULTIPOLYGON (((-36.39119 -10.50082, -36.39864... ## 2 Amap√° Norte ... AP MULTIPOLYGON (((-51.37380 -0.37053, -51.37337 ... ## 3 Amazonas Norte ... AM POLYGON ((-73.80098 -7.11145, -73.80106 -7.111... ## 4 Bahia Nordeste ... BA MULTIPOLYGON (((-46.32975 -13.25248, -46.33072... ## ## [5 rows x 5 columns] √â poss√≠vel perceber neste resultado que, ao carregar os dados, as representa√ß√µes espaciais presentes no arquivo, foram inseridas em uma coluna chamada geometry e que, al√©m dessa coluna, existem outras que vinculam m√∫ltiplas informa√ß√µes a cada uma das representa√ß√µes espaciais presentes no arquivo. Lembre-se, o m√©todo head √© herdado do Pandas, ele possibilita a visualiza√ß√£o das linhas iniciais da tabela de dados. A representa√ß√£o acima n√£o nos mostra todas as colunas de informa√ß√µes que temos no conjunto de dados carregados, para saber quais s√£o todas elas, utilizaremos o atributo columns. print(gdf.columns) ## Index([&#39;ESTADOS&#39;, &#39;REGIAO&#39;, &#39;COD_UF&#39;, &#39;UF&#39;, &#39;geometry&#39;], dtype=&#39;object&#39;) Olha que interessante! Para cada estado, h√° seu nome, a regi√£o a que pertence, sua Unidade da Federa√ß√£o (UF) e o c√≥digo desta UF. Agora que j√° sabemos como est√£o nossos dados, vamos voltar um pouco na coluna geometry. print(gdf[&quot;geometry&quot;].head(5)) ## 0 POLYGON ((-73.80098 -7.11145, -73.74084 -7.143... ## 1 MULTIPOLYGON (((-36.39119 -10.50082, -36.39864... ## 2 MULTIPOLYGON (((-51.37380 -0.37053, -51.37337 ... ## 3 POLYGON ((-73.80098 -7.11145, -73.80106 -7.111... ## 4 MULTIPOLYGON (((-46.32975 -13.25248, -46.33072... ## Name: geometry, dtype: geometry Entenda, a geometria escolhida para representar cada um dos estados do Brasil foi o poligono, e isto √© poss√≠vel de visualizar na coluna geometry. Outro fato importante sobre esta coluna √© que, ela n√£o precisa ter este nome, ele √© definido automaticamente pelo GeoPandas para que as coisas sejam padronizadas e fiquem mais simples, mas, caso eu queira alterar, posso fazer isto facilmente da seguinte forma. gdf = gdf.rename_geometry(&quot;geometria&quot;) Ao fazer isto, vamos visualizar as colunas do GeoDataFrame alterado. print(gdf.columns) ## Index([&#39;ESTADOS&#39;, &#39;REGIAO&#39;, &#39;COD_UF&#39;, &#39;UF&#39;, &#39;geometria&#39;], dtype=&#39;object&#39;) Mas, e se nos dados que eu estiver carregando existirem mais de uma coluna de representa√ß√µes espaciais, como o GeoPandas entende qual deve ser utilizada? Bem, por padr√£o ele escolhera a primeira delas e a tratar√° como a coluna geometry do conjunto de dados, por√©m se eu quiser fazer a altera√ß√£o, tamb√©m √© poss√≠vel. Primeiro, vamos aprender a identificar como o GeoPandas mostra a coluna que ele est√° utilizando como padr√£o, para isto o atributo geometry √© utilizado. print(gdf.geometry.head(5)) ## 0 POLYGON ((-73.80098 -7.11145, -73.74084 -7.143... ## 1 MULTIPOLYGON (((-36.39119 -10.50082, -36.39864... ## 2 MULTIPOLYGON (((-51.37380 -0.37053, -51.37337 ... ## 3 POLYGON ((-73.80098 -7.11145, -73.80106 -7.111... ## 4 MULTIPOLYGON (((-46.32975 -13.25248, -46.33072... ## Name: geometria, dtype: geometry Este atributo devolve os dados da coluna padr√£o de geometrias. Vamos ver qual √© o nome da coluna de onde ele retira tais dados. print(gdf.geometry.name) ## geometria O nome √© exatamente o mesmo da coluna que renomeamos! Vamos trocar esta coluna padr√£o, para fazer este teste, vou duplicar a coluna que cont√©m as geometrias, por√©m cada uma ter√° um nome. gdf[&quot;geometria_dois&quot;] = gdf[&quot;geometria&quot;] print(gdf.columns) ## Index([&#39;ESTADOS&#39;, &#39;REGIAO&#39;, &#39;COD_UF&#39;, &#39;UF&#39;, &#39;geometria&#39;, &#39;geometria_dois&#39;], dtype=&#39;object&#39;) Feito isto, vamos alterar a coluna padr√£o de geometrias gdf = gdf.set_geometry(&quot;geometria_dois&quot;) Ao visualizar o resultado, percebemos que a mudan√ßa foi realizada com sucesso. print(gdf.geometry.name) ## geometria_dois A diferen√ßa entre o m√©todo rename_geometry e set_geometry est√° no ponto em que, a set_geometry altera a coluna que est√° sendo considerada como padr√£o para geometrias, equanto a rename_geometry altera o nome da coluna padr√£o de geometrias. Por fim, vamos visualizar a disposi√ß√£o destes dados em uma figura, para isto, utilizamos o m√©todo plot. gdf.plot() O ponto a ser entendido do m√©todo plot √© que, ele utiliza a coluna de geometrias padr√£o para gerar a figura, ent√£o, caso haja alguma inconsist√™ncia neste coluna este m√©todo ter√° problemas. Esta l√≥gica se aplica a todos os outros m√©todos do GeoPandas que utilizam a representa√ß√£o espacial para fazer as opera√ß√µes. Vamos salvar os resultados em um arquivo shapefile, para isto, fa√ßamos a utiliza√ß√£o do m√©todo to_file. del gdf[&quot;geometria&quot;] # Removendo coluna extra de geometrias gdf.to_file(&#39;tmp/estados_do_brasil_editado.shp&#39;) N√£o deixe de consultar a documenta√ß√£o do Pandas e do GeoPandas, por conta das bibliotecas trabalharem juntas, muitos formas de dados podem ser escritos e tratados, no GeoPandas √© poss√≠vel at√© mesmo ler dados diretamente de um banco de dados espacial (PostGres com PostGIS). 3.2.3 Manipula√ß√£o geom√©trica O GeoPandas oferece diferentes m√©todos para a manipula√ß√£o dos dados espaciais carregados, esta se√ß√£o far√° a apresenta√ß√£o de alguns destes m√©todos. √â importante lembrar que, todos estes m√©todos est√£o orientados a coluna de geometria padr√£o, vista na subse√ß√£o anterior. As opera√ß√µes apresentadas nas subse√ß√µes a seguir, s√£o representadas por m√©todos e atributos das GeoSeries e dos GeoDataFrames. 3.2.3.1 area Vamos come√ßar com as opera√ß√µes de √°rea, que de forma an√°loga ao nome, c√°lcula a √°rea da geometria em quest√£o. Vejamos a Figura abaixo que faz uma representa√ß√£o desta opera√ß√£o em diferentes formas geom√©tricas. O resultado da opera√ß√£o, devolve o c√°lculo da √°rea, representado em vermelho na Figura acima. Para exemplificar, vamos utilizar o conjunto de dados dos estados do Brasil estados_do_brasil = gpd.read_file(&quot;../data/1_estados_do_brasil_shape/Brasil.shp&quot;) Lembre-se, este conjunto de dados est√° dispon√≠vel no reposit√≥rio do curso Depois de carregar os dados, vamos utilizar o atributo area, que realiza a opera√ß√£o e devolve a √†rea para cada uma das linhas do conjunto de dados print(estados_do_brasil.area.head(5)) # Exibindo somente as 5 primeiras ## 0 12.553132 ## 1 2.285972 ## 2 11.424936 ## 3 128.108383 ## 4 46.911114 ## dtype: float64 A √°rea √© devolvida na unidade de medida da proje√ß√£o espacial utilizada no conjunto de dados, estes detalhes ser√£o apresentados nas se√ß√µes seguintes. 3.2.3.2 bounds O atributo bounds devolve as coordenadas m√≠nimas e m√°ximas da regi√£o coberta pela geometria. Sua representa√ß√£o √© feita na Figura abaixo. Perceba que, para cada figura √© criado um ret√¢ngulo que a envolve (Tamb√©m chamado de ret√¢ngulo envolvente) e as coordenadas m√≠nimas e m√°ximas s√£o retiradas desses. Vejamos um exemplo print(estados_do_brasil.bounds.head(5)) ## minx miny maxx maxy ## 0 -73.990943 -11.144489 -66.619331 -7.111453 ## 1 -38.237442 -10.500822 -35.151669 -8.812208 ## 2 -54.875779 -1.235830 -49.875779 4.437122 ## 3 -73.801055 -9.814097 -56.097385 2.247063 ## 4 -46.629029 -18.349041 -37.339928 -8.532272 3.2.3.3 centroid O atributo centroid devolve o ponto central da geometria. Sua representa√ß√£o √© feita na Figura abaixo. O ponto retornado para cada geometria √© apresentado em vermelho. Vejamos um exemplo com o GeoPandas. centroids_dos_estados = estados_do_brasil.centroid Se olharmos para o resultado teremos uma GeoSeries com um ponto para cada um dos estados, vamos visualizar estes pontos rapidamente. centroids_dos_estados.plot() Para fazermos um pequeno experimento, famos pegar a figura com os estados e fazer seu plot junto com os centroids. base = estados_do_brasil.plot() centroids_dos_estados.plot(ax=base, marker=&quot;o&quot;, color=&quot;red&quot;) 3.2.3.4 buffer O m√©todo buffer cria um circulo entorno de um ponto, e pode ser aplicado em diferentes tipos de an√°lises espaciais. Sua representa√ß√£o √© feita na Figura abaixo. Para testar esta opera√ß√£o, vamos utilizar os centroids extra√≠dos na se√ß√£o anterior. buffers = centroids_dos_estados.buffer(2) Da mesma forma que outros m√©todos que trabalham com dist√¢ncias, os valores dependem diretamente das proje√ß√µes espaciais utilizadas. Vamos fazer um plot do resultado gerado sob o mapa dos estados do Brasil. base = estados_do_brasil.plot() base = buffers.plot(ax = base, color = &#39;yellow&#39;) # Adicionando os centroids tamb√©m, para testar =D centroids_dos_estados.plot(ax = base, color = &#39;red&#39;) 3.2.3.5 envelope Por fim, o m√©todo envelope cria o mesmo ret√¢ngulo envolve utilizado no atributo bounds, com a diferen√ßa que, neste caso a geometria √© devolvida. A representa√ß√£o desta opera√ß√£o √© feita na Figura abaixo. Para testar, vamos pegar os buffers gerados anteriormente e ent√£o gerar seu ret√¢ngulo envolvente. envelopes = buffers.envelope Da mesma forma que nos demais, vamos visualizar o resultado. base = estados_do_brasil.plot() envelopes.plot(ax = base, color = &#39;green&#39;) 3.2.4 Sele√ß√£o e filtro de dados O GeoPandas ainda fornece m√©todos para a sele√ß√£o e filtros de dados baseados na posi√ß√£o espacial. Nesta se√ß√£o veremos dois desses, que podem ser muito √∫teis nas mais diversas an√°lises. 3.2.4.1 distance Vamos come√ßar com o m√©todo distance, que calcula a dist√¢ncia entre duas geometrias. Sua opera√ß√£o √© representada na Figura abaixo. Para testar esta opera√ß√£o, vamos carregar dois dados vetoriais, cada um represetando um estado do Brasil. estado_maranhao = gpd.read_file(&quot;../data/2_estado_sp_shape/shape_estado-sp.shp&quot;) estado_saopaulo = gpd.read_file(&quot;../data/3_estado_ma_shape/shape_estado-ma.shp&quot;) Vamos visualizar os dois juntos. Nesta visualiza√ß√£o, para ela ter sentido, abaixo dos estados foi fazer o plot do mapa do Brasil. base = estados_do_brasil.plot() base = estado_maranhao.plot(ax = base, color = &#39;green&#39;) estado_saopaulo.plot(ax = base, color = &#39;yellow&#39;) Certo, vamos calcular a dist√¢ncia entre cada um deles. distancia = estado_saopaulo.distance(estado_maranhao) print(distancia) ## 0 9.809695 ## dtype: float64 Feito, com isto tem-se a dist√¢ncia entre as duas geometrias, que neste caso representa os estados do Maranh√£o e S√£o Paulo. Esta mesma opera√ß√£o pode ser utilizada como uma forma de consulta aos dados, por exemplo, buscar estados que estejam a X de dist√¢ncia de outro. 3.2.4.2 contains O m√©todo contains verifica se uma geometria est√° contida em outra, sua representa√ß√£o visual √© apresentada abaixo . Vamos fazer um teste da opera√ß√£o com o estado do Amazonas, verificando se sua geometria est√° contida nas nos dados de estados do Brasil. Primeiro, vamos retirar do GeoDataFrame as informa√ß√µes do estado do Amazonas, para isto aplicaremos um filtro booleano, herdado do Pandas. estado_amazonas = estados_do_brasil[estados_do_brasil[&quot;ESTADOS&quot;] == &quot;Amazonas&quot;] # Indexa√ß√£o booleana Agora vamos verificar se o estado est√° contido em alguma geometria dos estados do Brasil. amazonas_esta_presente = estados_do_brasil.contains(estado_amazonas) print(amazonas_esta_presente.head(10)) ## 0 False ## 1 False ## 2 False ## 3 True ## 4 False ## 5 False ## 6 False ## 7 False ## 8 False ## 9 False ## dtype: bool Veja que em uma das linhas apareceu True, isto indica que a geometria do estado do Amazonas est√° contida nesta, que se formos olhar a linha do GeoDataFrame com os dados do estado, indica exatamente a linha do estado do Amazonas. print(estados_do_brasil[amazonas_esta_presente]) ## ESTADOS REGIAO ... UF geometry ## 3 Amazonas Norte ... AM POLYGON ((-73.80098 -7.11145, -73.80106 -7.111... ## ## [1 rows x 5 columns] 3.2.4.3 intersects Por fim, na parte de sele√ß√£o atrav√©s dos dados espaciais, vamos testar o m√©todo intersects, que verifica se uma geometria faz intersec√ß√£o com outra. Vale lembrar que, √© tido como uma intersec√ß√£o, quando um objeto cruza de alguma maneira, seu limite e seu interior com outro objeto. A opera√ß√£o pode ser vista abaixo. Para realizar este teste, vamos carregar um arquivo que cont√©m todos rios do nosso pa√≠s. E ent√£o verificar quais desses fazem intersec√ß√£o com o estado do Par√°. rios_brasil = gpd.read_file(&quot;../data/4_rios_brasil/Brasil_rios.shp&quot;) Antes de continuar, vamos visualizar os dados, junto aos estados do Brasil. base = estados_do_brasil.plot(color = &quot;gray&quot;) rios_brasil.plot(ax = base, color = &#39;red&#39;) base = estados_do_brasil.plot(color = &quot;gray&quot;) rios_brasil.plot(ax = base, color = &#39;red&#39;) plt.show() Agora vamos pegar somente o estado do Par√° do conjunto de estados e verificar quais rios fazem intersec√ß√£o com ele. estado_para = estados_do_brasil[estados_do_brasil[&quot;ESTADOS&quot;] == &quot;Par√°&quot;] rios_intersect_para = rios_brasil.intersects(estado_para) print(rios_intersect_para.head(5)) ## 0 False ## 1 False ## 2 False ## 3 False ## 4 False ## dtype: bool O resultado √© uma lista booleana, desta forma, vamos filtrar o conjunto de dados de rios com este √≠ndice, e ent√£o verificar quais deles fazem intersec√ß√£o com o estado do Par√°. rios_para = rios_brasil[rios_intersect_para] Com os dados separados, vamos fazer um plot para melhor visualizar o resultado. Neste plot vamos utilizar o matplotlib, para criar v√°rios subplots. import matplotlib.pyplot as plt # Criando figura e os subplots fig, (ax1, ax2) = plt.subplots(ncols=2) base = estados_do_brasil.plot(ax = ax1, color = &#39;blue&#39;) rios_para.plot(ax = base, color = &#39;red&#39;) base = estado_para.plot(ax = ax2, color = &#39;gray&#39;) rios_para.plot(ax = base, color = &#39;red&#39;) plt.show() Veja que esta opera√ß√£o verificou somente aqueles que fazem intersec√ß√£o com as fronteiras, n√£o indicando que est√° contido ou pr√≥ximo ao estado. 3.2.5 Manipula√ß√£o de proje√ß√µes Uma opera√ß√£o muito importante quando se est√° trabalhando dados espaciais √© a manipula√ß√£o de suas proje√ß√µes, estas que como explicado no cap√≠tulo anterior, fazem as representa√ß√µes das geometrias no espa√ßo, o GeoPandas fornece um m√©todo muito simples para tal opera√ß√£o, o to_crs, que altera a proje√ß√£o dos dados sem grandes problemas. Este foi o cap√≠tulo sobre GeoPandas e suas facilidades de uso üåü, n√£o deixe de consultar a documenta√ß√£o oficial e fazer seus testes üí´. "],
["introdu√ß√£o-ao-postgis.html", "4 Introdu√ß√£o ao postgis üêò 4.1 Instala√ß√£o", " 4 Introdu√ß√£o ao postgis üêò Uma das principais caracter√≠sticas que diferenciam os bancos de dados geogr√°ficos dos demais bancos de dados convencionais, √© a presen√ßa de uma coluna com a finalidade de armazenar uma propriedade geogr√°fica do registro. Al√©m disso , os bancos de dados geogr√°ficos tamb√©m devem oferecer de forma otimizada suporte √† opera√ß√µes espaciais. Diferente de um passado n√£o muito distante, atualmente existem muitas alternativas de bancos de dados geogr√°ficos, como: SQL Server Spatial, ESRI ArcSDE, Oracle Spatial, GeoMesa, PostGIS, etc. Cada uma destas op√ß√µes tem o objetivo em comum trabalhar com dados geogr√°ficos e todas est√£o sendo muito utlizadas em diversos segmentos nos dias de hoje, sendo o PostGIS a mais popular de todas. O PostGIS √© uma extens√£o geogr√°fica open source para o SGDB (Sistema Gerenciador de Banco de Dados) PostgreSQL, lan√ßada em 2001 inicialmente por uma empresa canadense chamada Refractions Research. O PostGIS segue a padroniza√ß√£o estabelecida pelo OGC (Open GIS Consortium), que prov√™ suporte para todos os objetos e fun√ß√µes da especifica√ß√£o SFS (Simple Features for SQL). De forma concisa, a especifica√ß√£o SFS foi criada pelo OGC (cons√≥rcio formado por empresas, universidades, etc) e trata das quest√µes de representa√ß√£o da componente espacial e vetorial dos dados geogr√°ficos, garantindo assim, a interoperabilidade entre os sistemas os utilizam. Este cap√≠tulo tem como objetivo introduzir ao leitor √† extens√£o espacial PostGIS . Ao final, o leitor dever√° est√° apto a configurar corretamente o ambiente para a utiliza√ß√£o da ferramente, carregar arquivos vetoriais e realizar opera√ß√µes espaciais. 4.1 Instala√ß√£o Como o PostGIS √© uma extens√£o do PostgreSQL, primeiramente dever√° ser feita a instala√ß√£o do SGBD. Importante: N√£o esque√ßa o nome de usu√°rio e senha que voc√™ definir durante a instala√ß√£o, pois essas informa√ß√µes ser√£o de suma import√¢ncia, anote se necess√°rio. A vers√£o do PostgreSQL utilizada aqui √© ser√° a 11.5. A instala√ß√£o do PostgreSQL e PostGIS no sistema operacional windows, pode ser feita atrav√©s do instalador dispon√≠vel nesse link, para isso fique atento durante a instala√ß√£o e na segunda tela do assistente, no item Spatial Extensions marque a op√ß√£o PostGIS. A instala√ß√£o do PostgreSQL e PostGIS no sistema Operacional MacOS pode ser feita atrav√©s do gerenciador de pacotes brew, utilizado os seguintes comandos: brew install postgres brew install postgis Para a instala√ß√£o nos sistemas operacionais linux, utilize os seguintes comandos : sudo apt install postgresql postgresql-contrib sudo apt-get install postgis Para verificar se a instala√ß√£o do PostgreSQL foi realizada corretamente, abra o terminal e digite o seguinte comando: psql --version Se tudo ocorreu bem, dever√° aparecer uma sa√≠da com a vers√£o do PostgreSQL, algo parecido com psql (PostgreSQL) 11.5. Para verificar a instala√ß√£o do PostGIS, abra o terminal e execute o seguinte comando para abrir o interpretador do PostgreSQL: sudo -u &lt;user&gt; psql Obs: Substitua o trecho &lt;user&gt; para o usu√°rio do PostgreSQL definido na instala√ß√£o. Com o terminal do PostgreSQL aberto, execute o seguinte comando para verificar a vers√£o do PostGIS: SELECT PostGIS_version(); Se tudo estiver certo, dever√° aparecer como sa√≠da a vers√£o do PostGIS. Para sair do interpretador psql, basta executar o comando \\q. E com isso finalizamos as configura√ß√£o iniciais necess√°rias iniciar os trabalhos com o PostGIS. Para mais informa√ß√µes, consulte a p√°gina oficial do PostGIS em: https://postgis.net/install. Na pr√≥xima se√ß√£o iremos criar um banco de dados novo e habilitar nele a extens√£o espacial PostGIS, para que possam ser executadas as nossas primeiras consultas espaciais. "]
]
