<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>

  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <title></title>
  <meta name="description" content="" />
  <meta name="generator" content="bookdown 0.16 and GitBook 2.6.7" />

  <meta property="og:title" content="" />
  <meta property="og:type" content="book" />
  
  
  
  

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="" />
  
  
  




  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  
  
<link rel="prev" href="r.html"/>
<link rel="next" href="introdução-ao-postgis.html"/>
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-table.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-clipboard.css" rel="stylesheet" />











<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="1" data-path="introdução.html"><a href="introdução.html"><i class="fa fa-check"></i><b>1</b> Introdução 🌍</a><ul>
<li class="chapter" data-level="1.1" data-path="introdução.html"><a href="introdução.html#representações-de-dados-espaciais"><i class="fa fa-check"></i><b>1.1</b> Representações de dados espaciais</a><ul>
<li class="chapter" data-level="1.1.1" data-path="introdução.html"><a href="introdução.html#vetoriais"><i class="fa fa-check"></i><b>1.1.1</b> Vetoriais</a></li>
<li class="chapter" data-level="1.1.2" data-path="introdução.html"><a href="introdução.html#matriciais"><i class="fa fa-check"></i><b>1.1.2</b> Matriciais</a></li>
</ul></li>
<li class="chapter" data-level="1.2" data-path="introdução.html"><a href="introdução.html#sistema-de-referência-espacial"><i class="fa fa-check"></i><b>1.2</b> Sistema de referência espacial</a></li>
<li class="chapter" data-level="1.3" data-path="introdução.html"><a href="introdução.html#projeções-cartográficas"><i class="fa fa-check"></i><b>1.3</b> Projeções cartográficas</a><ul>
<li class="chapter" data-level="1.3.1" data-path="introdução.html"><a href="introdução.html#tipos-de-projeção"><i class="fa fa-check"></i><b>1.3.1</b> Tipos de projeção</a></li>
</ul></li>
<li class="chapter" data-level="1.4" data-path="introdução.html"><a href="introdução.html#sistema-de-coordenadas"><i class="fa fa-check"></i><b>1.4</b> Sistema de Coordenadas</a><ul>
<li class="chapter" data-level="1.4.1" data-path="introdução.html"><a href="introdução.html#sistemas-de-coordenadas-geográficas"><i class="fa fa-check"></i><b>1.4.1</b> Sistemas de Coordenadas Geográficas</a></li>
<li class="chapter" data-level="1.4.2" data-path="introdução.html"><a href="introdução.html#coordenadas-planas"><i class="fa fa-check"></i><b>1.4.2</b> Coordenadas planas</a></li>
<li class="chapter" data-level="1.4.3" data-path="introdução.html"><a href="introdução.html#códigos-epsg"><i class="fa fa-check"></i><b>1.4.3</b> Códigos EPSG</a></li>
</ul></li>
<li class="chapter" data-level="1.5" data-path="introdução.html"><a href="introdução.html#open-geospatial-consortium-ogc"><i class="fa fa-check"></i><b>1.5</b> Open Geospatial Consortium (OGC)</a></li>
<li class="chapter" data-level="1.6" data-path="introdução.html"><a href="introdução.html#relacionamentos-espaciais-nomeados"><i class="fa fa-check"></i><b>1.6</b> Relacionamentos espaciais nomeados</a><ul>
<li class="chapter" data-level="1.6.1" data-path="introdução.html"><a href="introdução.html#relacionamentos-espaciais"><i class="fa fa-check"></i><b>1.6.1</b> Relacionamentos espaciais</a></li>
<li class="chapter" data-level="1.6.2" data-path="introdução.html"><a href="introdução.html#restrições-espaciais"><i class="fa fa-check"></i><b>1.6.2</b> Restrições espaciais</a></li>
</ul></li>
<li class="chapter" data-level="1.7" data-path="introdução.html"><a href="introdução.html#matriz-de-9-interseções-estendida-dimensionalmente"><i class="fa fa-check"></i><b>1.7</b> Matriz de 9-Interseções Estendida dimensionalmente</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="r.html"><a href="r.html"><i class="fa fa-check"></i><b>2</b> R 💎</a><ul>
<li class="chapter" data-level="2.1" data-path="r.html"><a href="r.html#tibble"><i class="fa fa-check"></i><b>2.1</b> Tibble</a><ul>
<li class="chapter" data-level="2.1.1" data-path="r.html"><a href="r.html#tidyverse"><i class="fa fa-check"></i><b>2.1.1</b> Tidyverse</a></li>
<li class="chapter" data-level="2.1.2" data-path="r.html"><a href="r.html#manipulação-de-dados"><i class="fa fa-check"></i><b>2.1.2</b> Manipulação de dados</a></li>
</ul></li>
<li class="chapter" data-level="2.2" data-path="r.html"><a href="r.html#sf"><i class="fa fa-check"></i><b>2.2</b> SF</a><ul>
<li class="chapter" data-level="2.2.1" data-path="r.html"><a href="r.html#tipos-geométricos"><i class="fa fa-check"></i><b>2.2.1</b> Tipos Geométricos</a></li>
<li class="chapter" data-level="2.2.2" data-path="r.html"><a href="r.html#leitura-e-escrita-de-dados-vetoriais"><i class="fa fa-check"></i><b>2.2.2</b> Leitura e escrita de dados vetoriais</a></li>
<li class="chapter" data-level="2.2.3" data-path="r.html"><a href="r.html#relacionamentos-espaciais-1"><i class="fa fa-check"></i><b>2.2.3</b> Relacionamentos Espaciais</a></li>
<li class="chapter" data-level="2.2.4" data-path="r.html"><a href="r.html#operadores-métricos"><i class="fa fa-check"></i><b>2.2.4</b> Operadores Métricos</a></li>
<li class="chapter" data-level="2.2.5" data-path="r.html"><a href="r.html#sistemas-de-referências"><i class="fa fa-check"></i><b>2.2.5</b> Sistemas de referências</a></li>
<li class="chapter" data-level="2.2.6" data-path="r.html"><a href="r.html#materiais-recomendados"><i class="fa fa-check"></i><b>2.2.6</b> Materiais recomendados</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="3" data-path="python.html"><a href="python.html"><i class="fa fa-check"></i><b>3</b> Python ✨</a><ul>
<li class="chapter" data-level="3.1" data-path="python.html"><a href="python.html#pandas"><i class="fa fa-check"></i><b>3.1</b> Pandas 🐼</a><ul>
<li class="chapter" data-level="3.1.1" data-path="python.html"><a href="python.html#manipulação-de-dados-1"><i class="fa fa-check"></i><b>3.1.1</b> Manipulação de dados</a></li>
</ul></li>
<li class="chapter" data-level="3.2" data-path="python.html"><a href="python.html#geopandas"><i class="fa fa-check"></i><b>3.2</b> GeoPandas 🌐🐼</a><ul>
<li class="chapter" data-level="3.2.1" data-path="python.html"><a href="python.html#geoseries-e-geodataframes"><i class="fa fa-check"></i><b>3.2.1</b> GeoSeries e GeoDataFrames</a></li>
<li class="chapter" data-level="3.2.2" data-path="python.html"><a href="python.html#leitura-e-escrita-de-dados-1"><i class="fa fa-check"></i><b>3.2.2</b> Leitura e escrita de dados</a></li>
<li class="chapter" data-level="3.2.3" data-path="python.html"><a href="python.html#manipulação-geométrica"><i class="fa fa-check"></i><b>3.2.3</b> Manipulação geométrica</a></li>
<li class="chapter" data-level="3.2.4" data-path="python.html"><a href="python.html#seleção-e-filtro-de-dados"><i class="fa fa-check"></i><b>3.2.4</b> Seleção e filtro de dados</a></li>
<li class="chapter" data-level="3.2.5" data-path="python.html"><a href="python.html#manipulação-de-projeções"><i class="fa fa-check"></i><b>3.2.5</b> Manipulação de projeções</a></li>
</ul></li>
</ul></li>
<li class="chapter" data-level="4" data-path="introdução-ao-postgis.html"><a href="introdução-ao-postgis.html"><i class="fa fa-check"></i><b>4</b> Introdução ao postgis 🐘</a><ul>
<li class="chapter" data-level="4.1" data-path="introdução-ao-postgis.html"><a href="introdução-ao-postgis.html#instalação"><i class="fa fa-check"></i><b>4.1</b> Instalação</a></li>
<li class="chapter" data-level="4.2" data-path="introdução-ao-postgis.html"><a href="introdução-ao-postgis.html#um-pouco-de-sql"><i class="fa fa-check"></i><b>4.2</b> Um pouco de SQL</a><ul>
<li class="chapter" data-level="4.2.1" data-path="introdução-ao-postgis.html"><a href="introdução-ao-postgis.html#acessando-a-interface-postgresql"><i class="fa fa-check"></i><b>4.2.1</b> Acessando a interface PostgreSQL</a></li>
<li class="chapter" data-level="4.2.2" data-path="introdução-ao-postgis.html"><a href="introdução-ao-postgis.html#criando-uma-nova-base-de-dados"><i class="fa fa-check"></i><b>4.2.2</b> Criando uma nova base de dados</a></li>
<li class="chapter" data-level="4.2.3" data-path="introdução-ao-postgis.html"><a href="introdução-ao-postgis.html#well-known-text"><i class="fa fa-check"></i><b>4.2.3</b> Well-known text</a></li>
</ul></li>
<li class="chapter" data-level="4.3" data-path="introdução-ao-postgis.html"><a href="introdução-ao-postgis.html#funções-geométricas"><i class="fa fa-check"></i><b>4.3</b> Funções geométricas</a></li>
<li class="chapter" data-level="4.4" data-path="introdução-ao-postgis.html"><a href="introdução-ao-postgis.html#relacionamentos-espaciais-2"><i class="fa fa-check"></i><b>4.4</b> Relacionamentos espaciais</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="para-saber-mais.html"><a href="para-saber-mais.html"><i class="fa fa-check"></i><b>5</b> Para saber mais 🔭</a><ul>
<li class="chapter" data-level="5.1" data-path="para-saber-mais.html"><a href="para-saber-mais.html#impactos-da-resolução-espacial-de-modelos-digitais-de-superfície-no-cálculo-da-perda-de-solo-através-da-eups-em-ambiente-urbano"><i class="fa fa-check"></i><b>5.1</b> <strong>IMPACTOS DA RESOLUÇÃO ESPACIAL DE MODELOS DIGITAIS DE SUPERFÍCIE NO CÁLCULO DA PERDA DE SOLO ATRAVÉS DA EUPS EM AMBIENTE URBANO</strong></a></li>
<li class="chapter" data-level="5.2" data-path="para-saber-mais.html"><a href="para-saber-mais.html#criação-e-avaliação-de-mapas-de-suscetibilidade-a-inundação-para-o-município-de-iguape-estado-de-são-paulo"><i class="fa fa-check"></i><b>5.2</b> <strong>CRIAÇÃO E AVALIAÇÃO DE MAPAS DE SUSCETIBILIDADE A INUNDAÇÃO PARA O MUNICÍPIO DE IGUAPE, ESTADO DE SÃO PAULO</strong></a></li>
<li class="chapter" data-level="5.3" data-path="para-saber-mais.html"><a href="para-saber-mais.html#conectividade-demográfica-e-aclimatação-de-peixes-recifais-do-gênero-sparisoma-em-cenário-de-mudanças-climáticas"><i class="fa fa-check"></i><b>5.3</b> <strong>CONECTIVIDADE DEMOGRÁFICA E ACLIMATAÇÃO DE PEIXES RECIFAIS DO GÊNERO SPARISOMA EM CENÁRIO DE MUDANÇAS CLIMÁTICAS</strong></a></li>
<li class="chapter" data-level="5.4" data-path="para-saber-mais.html"><a href="para-saber-mais.html#parametrização-de-algoritmos-empíricos-e-algoritmo-quasi-analítico-qaa-para-estimativa-de-clorofila-a-em-lagos-da-várzea-do-rio-amazonas"><i class="fa fa-check"></i><b>5.4</b> <strong>PARAMETRIZAÇÃO DE ALGORITMOS EMPÍRICOS E ALGORITMO QUASI-ANALÍTICO QAA PARA ESTIMATIVA DE CLOROFILA-A EM LAGOS DA VÁRZEA DO RIO AMAZONAS</strong></a></li>
<li class="chapter" data-level="5.5" data-path="para-saber-mais.html"><a href="para-saber-mais.html#quantificação-remota-da-concentração-de-sólidos-totais-e-inorgânicos-em-suspensão-em-lagos-da-planície-de-inundação-do-baixo-amazonas---uma-abordagem-multi-sensor"><i class="fa fa-check"></i><b>5.5</b> <strong>QUANTIFICAÇÃO REMOTA DA CONCENTRAÇÃO DE SÓLIDOS TOTAIS E INORGÂNICOS EM SUSPENSÃO EM LAGOS DA PLANÍCIE DE INUNDAÇÃO DO BAIXO AMAZONAS - UMA ABORDAGEM MULTI-SENSOR</strong></a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="references.html"><a href="references.html"><i class="fa fa-check"></i><b>6</b> References</a></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./"></a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="python" class="section level1">
<h1><span class="header-section-number">3</span> Python ✨</h1>
<p>Python é uma linguagem de programação versátil, multiparadigma, que permite aos desenvolvedores criar rápidas soluções para seus problemas sem grandes preocupações com a sintaxe e formas de uso da linguagem.</p>
<p>Tais características fazem Python alcançar os mais variados nichos de aplicação. Por ser uma linguagem geral para atingir tais nichos, foram criadas pela comunidade de Python diversas bibliotecas, todas seguindo a ideia da simplicidade de aplicação e prototipação da linguagem. É neste contexto que surge o GeoPandas, que fornece extensões de uso espacial para uma biblioteca de análise de dados muito conhecida na comunidade Python, o Pandas.</p>
<p>Desta forma, este capítulo busca explicar as principais formas de utilização do GeoPandas. Por ser baseada no Pandas, há uma pequena seção que trata sobre o uso básico da linguagem, mas é recomendado que o leitor também conheça tal biblioteca, para isto, existe o <a href="https://dataat.github.io/introducao-analise-de-dados/introducao.html">curso de introdução à análise de dados</a>, que explica os principais conceitos de utilização do Pandas, não deixe de conferir!</p>
<div id="pandas" class="section level2">
<h2><span class="header-section-number">3.1</span> Pandas 🐼</h2>
<p>Com a necessidade de facilitar todo o processo de análise de dados, através de uma linguagem simples e amigável, a comunidade Python criou o Pandas, uma biblioteca que disponibiliza métodos de alto nível para a manipulação, processamento e análise dos mais variados tipos de dados.</p>
<p>Através dos métodos desta biblioteca é possível aplicar todo o ciclo de análise de dados, este indo desde a coleta até o processamento e análise. Para realizar tais atividades, o pandas disponibiliza diversas estruturas de dados, sendo as <code>Series</code> e os <code>DataFrames</code> as principais.</p>
<p>Cada uma dessas estruturas de dados, trata especificamente de uma forma de realizar a abstração do formato dos dados em código, isto faz com que seja necessário o entendimento das principais diferenças entre cada uma delas, para que seja possível realizar sua correta aplicação. Vamos buscar comparar cada uma dessas estruturas para entender suas diferenças.</p>
<p>As <code>Series</code> são estruturas de dados unidimensionais, possuindo apenas uma dimensão que pode ser manipulada, tal dimensão sendo chamada de índice. Já os <code>DataFrames</code> apresentam duas dimensões para a manipulação.</p>
<p>Estas características, na prática, indicam que, as <code>Series</code> apenas representar vetores, enquanto os <code>DataFrames</code> podem representar matrizes de N-Dimensões. Para esta ideia ficar clara, vejamos a Figura abaixo.</p>
<center>
<div style="width:500px; height:400px">
<div class="figure">
<img src="res/3_python/series_vs_dataframe.svg" />

</div>
</div>
</center>
<p>Perceba que, as <code>Series</code> possuem o campo para o armazenamento dos dados (Representado em Azul), e o índice (Representado em roxo), não podendendo ser adicionado nenhum outro campo, isto faz com que, todos os dados tenham de ser armazenados em apenas uma coluna, em várias linhas.</p>
<p>Para o <code>DataFrame</code> o cenário apresentado na Figura é diferente, além dos índices, há também as colunas (Representada em vermelho), o que permite que dentro desta estrutura existam não só um conjunto de linhas, como as <code>Series</code> mas sim um conjunto de colunas, onde cada uma dessas possuem várias linhas. Na prática o que fica subentendido é que, os <code>DataFrames</code> são um conjunto de <code>Series</code>.</p>
<center>
<img src="res/3_python/relacoes_pandas.svg" />
</center>
<p>Isto ocorre já que, cada uma das colunas criadas dentro do <code>DataFrame</code> são <code>Series</code>, o que acaba gerando um efeito muito interessante na API do Pandas, boa parte dos métodos disponíveis para as <code>Series</code> também estão presentes nos <code>DataFrames</code>. Vamos ver alguns exemplos em código para fixar a diferença entre essas duas estruturas de dados.</p>
<div id="manipulação-de-dados-1" class="section level3">
<h3><span class="header-section-number">3.1.1</span> Manipulação de dados</h3>
<p>Vamos começar criando uma <code>Series</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> pandas <span class="im">as</span> pd

sr <span class="op">=</span> pd.Series([<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span>])</code></pre></div>
<p>Pronto! Acabamos de criar uma <code>Series</code> com uma lista de valores, vejamos como ela está sendo representada.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(sr)</code></pre></div>
<pre><code>## 0    1
## 1    2
## 2    3
## 3    4
## 4    5
## dtype: int64</code></pre>
<p>A representação está da mesma forma que vimos antes. Vamos agora fazer uma pequena manipulação dos dados, para isso, utilizaremos os métodos <code>loc</code> e <code>iloc</code> disponíveis dentro do objeto <code>Series</code> gerado, onde o método <code>loc</code> busca o índice com o nome inserido e o <code>iloc</code> busca o índice com a posição inserida. A assinatura de cada um dos métodos está descrita abaixo. Lembre-se que este método está presente tanto na classe <code>Series</code> como na classe <code>DataFrame</code>.</p>
<table>
<thead>
<tr class="header">
<th>DataFrame</th>
<th align="center">Series</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>.loc[linha, coluna]</td>
<td align="center">.loc[linha]</td>
</tr>
<tr class="even">
<td>.iloc[linha]</td>
<td align="center">.iloc[linha]</td>
</tr>
</tbody>
</table>
<p>Antes de fazermos o teste destes métodos, vamos alterar o índice da nossa <code>Series</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Vamos visualizar o índice</span>
<span class="bu">print</span>(sr.index)</code></pre></div>
<pre><code>## RangeIndex(start=0, stop=5, step=1)</code></pre>
<p>O atributo <code>index</code> devolve os elementos que estão no índice, para fazer sua mudança, basta realizar uma atribuição, veja.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">sr.index <span class="op">=</span> [<span class="st">&quot;um&quot;</span>, <span class="st">&quot;dois&quot;</span>, <span class="st">&quot;tres&quot;</span>, <span class="st">&quot;quatro&quot;</span>, <span class="st">&quot;cinco&quot;</span>]

<span class="bu">print</span>(sr.index)</code></pre></div>
<pre><code>## Index([&#39;um&#39;, &#39;dois&#39;, &#39;tres&#39;, &#39;quatro&#39;, &#39;cinco&#39;], dtype=&#39;object&#39;)</code></pre>
<p>Fizemos esta mudança, para que cada um dos métodos <code>loc</code> e <code>iloc</code> seja mais simples de entender. Certo, vamos começar buscando a linha que tenha o nome <code>dois</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(sr.loc[<span class="st">&quot;dois&quot;</span>])</code></pre></div>
<pre><code>## 2</code></pre>
<p>Agora vamos buscar a linha que está na posição dois.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(sr.iloc[<span class="dv">1</span>]) <span class="co"># Lembre-se, o Python começa a contar no zero =D</span></code></pre></div>
<pre><code>## 2</code></pre>
<p>Percebeu? Temos o mesmo resultado, muito interessante não ? Além disso ainda posso aplicar filtros sob os dados,utilizando o conceito de <code>indexação booleana</code>, onde através de um vetor de <code>VERDADEIRO</code> e <code>FALSO</code> é possível selecionar as linhas.</p>
<p>Vamos buscar somente os valores que são acima de três.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(sr[sr <span class="op">&gt;</span> <span class="dv">3</span>])</code></pre></div>
<pre><code>## quatro    4
## cinco     5
## dtype: int64</code></pre>
<blockquote>
<p>Dica: O que ocorre nesta parte é, dentro das chaves de <code>sr</code> (sr[]) é passado a expressão <code>sr &gt; 3</code> que devolve uma lista de verdadeiros e falsos, fazendo assim o filtro.</p>
</blockquote>
<p>Muito interessante! Mas até aqui trabalhamos com apenas uma dimensão, vamos tentar acrescentar mais, para isto, primeiro vamos criar uma matriz.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">matriz <span class="op">=</span> [
  [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>], [<span class="dv">4</span>, <span class="dv">5</span>, <span class="dv">6</span>]
]</code></pre></div>
<p>A matriz criada é representada por uma lista de listas. Vamos tentar criar uma <code>Series</code> com esta matriz.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">sr <span class="op">=</span> pd.Series(matriz)

<span class="bu">print</span>(sr)</code></pre></div>
<pre><code>## 0    [1, 2, 3]
## 1    [4, 5, 6]
## dtype: object</code></pre>
<p>Eita! Perceba que, em cada linha há uma lista de valores, o que é ruim! Já que a manipulação fica difícil (Tenta fazer uma indexação booleana, vai falhar 😢).</p>
<p>Para este caso, existem os <code>DataFrames</code>! Vamos começar criando um com a mesma matriz gerada anteriormente.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df <span class="op">=</span> pd.DataFrame(matriz)

<span class="bu">print</span>(df)</code></pre></div>
<pre><code>##    0  1  2
## 0  1  2  3
## 1  4  5  6</code></pre>
<p>Opa! Agora o cenário é outro, conseguimos colocar cada um dos valores em seu devido lugar. Perceba que a representação mudou bastante, aqui temos várias colunas de dados, e mesmo assim, todos os métodos já apresentados até aqui funcionam. Vai lá, tenta!</p>
<p>Uma coisa importante sobre os <code>DataFrames</code> são suas colunas, para acessar elas podemos fazer da seguinte forma.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df[<span class="dv">0</span>])</code></pre></div>
<pre><code>## 0    1
## 1    4
## Name: 0, dtype: int64</code></pre>
<p>Viu! Estamos acessando a primeira coluna, se fizermos a mesma coisa, com a segunda também vai funcionar (Tenta inserir o número 1, para você ver o que acontece).</p>
<blockquote>
<p>Dica: Ao fazer df[0], estamos buscando o “nome” da coluna, e não sua posição</p>
</blockquote>
<p>Da mesma forma que eu podemos recuperar o índice com o atributo <code>index</code> podemos recuperar as colunas com o atributo <code>columns</code></p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df.columns)</code></pre></div>
<pre><code>## RangeIndex(start=0, stop=3, step=1)</code></pre>
<p>Para fazer a mudança dos nomes de cada coluna a mesma regra do <code>index</code> é válida.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">df.columns <span class="op">=</span> [<span class="st">&quot;col1&quot;</span>, <span class="st">&quot;col2&quot;</span>, <span class="st">&quot;col3&quot;</span>]

<span class="bu">print</span>(df.columns)</code></pre></div>
<pre><code>## Index([&#39;col1&#39;, &#39;col2&#39;, &#39;col3&#39;], dtype=&#39;object&#39;)</code></pre>
<p>Vamos recuperar a primeira coluna novamente</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(df[<span class="st">&quot;col1&quot;</span>])</code></pre></div>
<pre><code>## 0    1
## 1    4
## Name: col1, dtype: int64</code></pre>
<p>Assim, fica mais fácil entender que, quando se trata de colunas, estamos buscando os nomes, e não simplesmente as posições.</p>
<p>Bom, agora que já entendemos toda a utilização básica do Pandas, vamos começar a falar um pouco sobre o GeoPandas 💜</p>
</div>
</div>
<div id="geopandas" class="section level2">
<h2><span class="header-section-number">3.2</span> GeoPandas 🌐🐼</h2>
<p>Com o entendimento do que é a biblioteca Pandas, suas estruturas de dados e principais características, o estudo do GeoPandas pode ser iniciado. Mas o que é o GeoPandas ?</p>
<blockquote>
<p>GeoPandas é um projeto open-source que busca facilitar o trabalho com dados vetoriais em Python, para isto, tem como base as estruturas de dados do Pandas</p>
</blockquote>
<p>Desta forma, a ideia básica por trás do GeoPandas é adicionar o suporte a manipulação de dados espaciais as estruturas de dados do Pandas, e com isto prover formas de manipulação simples e direta a tais dados.</p>
<p>Para fazer isto, o GeoPandas utiliza estruturas de dados geométricas implementadas pela biblioteca <a href="https://shapely.readthedocs.io/en/stable/manual.html">Shapely</a> dentro das <code>Series</code> e dos <code>DataFrames</code>. Com esta adição, duas estruturas de dados surgem, as <code>GeoSeries</code> e os <code>GeoDataFrames</code>.</p>
<p>Este conceito pode ser melhor entendido com a observação da Figura abaixo.</p>
<center>
<img src="res/3_python/relacoes_pandas_e_geopandas.svg" />
</center>
<p>Perceba que, há a mesma estrutura que foi apresentada na seção anterior, com as geometrias sendo o diferencial nas estruturas de dados.</p>
<p>Na prática o que ocorre é, todas as formas de manipulação geométricas, que como citadas são implementadas com o Shapely, são implementadas em uma classe <code>GeoPandasBase</code> que é extendida pelas <code>GeoSeries</code> e <code>GeoDataFrames</code>, da mesma forma, essas também extendem as estruturas de dados equivalentes do Pandas, veja a Figura abaixo.</p>
<center>
<img src="res/3_python/geopandas_classes.svg" />
</center>
<p>Como a <code>GeoSeries</code> e os <code>GeoDataFrames</code> são especializações diretas das <code>Series</code> e dos <code>DataFrames</code> as mesmas características são mantidas, onde, respectivamente, um armazena apenas uma coluna de valores, tendo uma dimensão de manipulação e o outro armazena diversas colunas com duas dimensões de manipulação, da mesma forma como apresentado na seção anterior.</p>
<p>Para fixar o funcionamento de cada uma dessas estruturas, vamos fazer alguns testes com a API do GeoPandas.</p>
<div id="geoseries-e-geodataframes" class="section level3">
<h3><span class="header-section-number">3.2.1</span> GeoSeries e GeoDataFrames</h3>
<p>Para começar os testes, vamos importar a biblioteca de geometrias, <code>Shapely</code> e o GeoPandas.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> shapely
<span class="im">import</span> geopandas <span class="im">as</span> gpd</code></pre></div>
<p>Agora, vamos criar uma <code>GeoSeries</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">gsr <span class="op">=</span> gpd.GeoSeries([
  shapely.geometry.Point(<span class="dv">1</span>, <span class="dv">1</span>)
])</code></pre></div>
<blockquote>
<p>Dica: A geometria criada não possui qualquer tipo de referência espacial, portanto representa apenas um ponto no plano cartesiano.</p>
</blockquote>
<p>Veja que acabamos de criar uma <code>GeoSeries</code> que armazena uma geometria de ponto, vamos visualizar o objeto criado.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(gsr)</code></pre></div>
<pre><code>## 0    POINT (1.00000 1.00000)
## dtype: geometry</code></pre>
<p>A forma é exatamente a mesma de uma <code>Series</code>. Vamos criar um novo objeto com mais geometrias inseridas.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">gsr <span class="op">=</span> gpd.GeoSeries([
  shapely.geometry.Point(<span class="dv">1</span>, <span class="dv">1</span>),
  shapely.geometry.Point(<span class="dv">2</span>, <span class="dv">2</span>),
  shapely.geometry.Point(<span class="dv">4</span>, <span class="dv">3</span>)
])

<span class="bu">print</span>(gsr)</code></pre></div>
<pre><code>## 0    POINT (1.00000 1.00000)
## 1    POINT (2.00000 2.00000)
## 2    POINT (4.00000 3.00000)
## dtype: geometry</code></pre>
<p>Caso eu queira visualizar não só a tabela, mas sim a representação das geometrias criadas no espaço, é possível utilizar o método <code>plot</code>.</p>
<pre><code>gsr.plot()</code></pre>
<center>
<img src="intro-analise-de-dados-espaciais_files/figure-html/unnamed-chunk-95-1.png" /><!-- -->
</center>
<p>Mas as <code>GeoSeries</code> podem ser limitadas em alguns casos, imagine que para a realização de um estudo seja necessário não só a geolocalização ou a representação geométrica no espaço, mas também características do ambiente, qualquer tipo de informação que não a espacial. Nestes casos podemos utilizar os <code>GeoDataFrames</code> que além de colunas de geometria permitem o armazenamento de outras informações, isto por permitir múltiplas colunas. Vamos criar um para fazer testes.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">gdf <span class="op">=</span> gpd.GeoDataFrame({
  <span class="st">&#39;atributo_a&#39;</span>: [<span class="dv">10</span>, <span class="dv">11</span>, <span class="dv">12</span>],
  <span class="st">&#39;geometria&#39;</span>: [
    shapely.geometry.Point(<span class="dv">1</span>, <span class="dv">1</span>),
    shapely.geometry.Point(<span class="dv">2</span>, <span class="dv">2</span>),
    shapely.geometry.Point(<span class="dv">4</span>, <span class="dv">3</span>)
  ]
})</code></pre></div>
<p>Visualizando o resultado</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(gdf)</code></pre></div>
<pre><code>##    atributo_a    geometria
## 0          10  POINT (1 1)
## 1          11  POINT (2 2)
## 2          12  POINT (4 3)</code></pre>
<p>Agora as geometrias passam a ser vinculadas com outros valores, o que pode ser muito útil em vários cenários. Até aqui foram criadas geometrias sem nenhum tipo de ligação com o mundo real, então, vamos agora trabalhar um pouco com dados que façam esta representação, para isto, vejamos como carregar dados espaciais com o GeoPandas.</p>
</div>
<div id="leitura-e-escrita-de-dados-1" class="section level3">
<h3><span class="header-section-number">3.2.2</span> Leitura e escrita de dados</h3>
<p>Além de todas as características citadas até aqui, o GeoPandas ainda ajuda na leitura e na escrita de dados vetoriais, tudo seguindo o padrão de facilidade de uso do Pandas.</p>
<p>Para realizar essas operações o GeoPandas utiliza como base a biblioteca <a href="https://fiona.readthedocs.io/en/latest/manual.html">Fiona</a>, que traz suporte a leitura e escrita de uma enorme variedade de formatos vetoriais, sendo alguns deles:</p>
<ul>
<li>GeoJSON;</li>
<li>GPSTrackMaker;</li>
<li>ESRI Shapefile;</li>
<li>FileGDB;</li>
<li>OpenFileGDB.</li>
</ul>
<p>Além destes formatos a biblioteca aceita vários outros, para a lista completa de formatos suportados, consulte a <a href="https://fiona.readthedocs.io/en/latest/manual.html">documentação</a> do Fiona.</p>
<p>Para fazer alguns testes utilizando as funcionalidades de leitura dos dados, vamos carregar um dado vetorial, dos estados do Brasil que estão armazenados em um <code>shapefile</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">gdf <span class="op">=</span> gpd.read_file(<span class="st">&quot;../data/1_estados_do_brasil_shape/Brasil.shp&quot;</span>)</code></pre></div>
<blockquote>
<p>Estes dados estão disponíveis no <a href="https://github.com/dataAt/introducao-analise-de-dados-espaciais/tree/master/data">repositório</a> do curso.</p>
</blockquote>
<p>Com os dados carregados, vamos visualizar qual foi a estrutura gerada ao carregar os dados.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(<span class="bu">type</span>(gdf))</code></pre></div>
<pre><code>## &lt;class &#39;geopandas.geodataframe.GeoDataFrame&#39;&gt;</code></pre>
<p>Um <code>GeoDataFrame</code>! Isto é feito por padrão pela biblioteca, assim, independente do formato de entrada, o GeoPandas busca inserir os dados dentro de um <code>GeoDataFrame</code>. Certo, vamos olhar então o que está dentro deste objeto.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(gdf.head(<span class="dv">5</span>))</code></pre></div>
<pre><code>##     ESTADOS    REGIAO  COD_UF  UF                                           geometry
## 0      Acre     Norte    12.0  AC  POLYGON ((-73.80098 -7.11145, -73.74084 -7.143...
## 1   Alagoas  Nordeste    27.0  AL  MULTIPOLYGON (((-36.39119 -10.50082, -36.39864...
## 2     Amapá     Norte    16.0  AP  MULTIPOLYGON (((-51.37380 -0.37053, -51.37337 ...
## 3  Amazonas     Norte    13.0  AM  POLYGON ((-73.80098 -7.11145, -73.80106 -7.111...
## 4     Bahia  Nordeste    29.0  BA  MULTIPOLYGON (((-46.32975 -13.25248, -46.33072...</code></pre>
<p>É possível perceber neste resultado que, ao carregar os dados, as representações espaciais presentes no arquivo, foram inseridas em uma coluna chamada <code>geometry</code> e que, além dessa coluna, existem outras que vinculam múltiplas informações a cada uma das representações espaciais presentes no arquivo.</p>
<blockquote>
<p>Lembre-se, o método <code>head</code> é herdado do Pandas, ele possibilita a visualização das linhas iniciais da tabela de dados.</p>
</blockquote>
<p>A representação acima não nos mostra todas as colunas de informações que temos no conjunto de dados carregados, para saber quais são todas elas, utilizaremos o atributo <code>columns</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(gdf.columns)</code></pre></div>
<pre><code>## Index([&#39;ESTADOS&#39;, &#39;REGIAO&#39;, &#39;COD_UF&#39;, &#39;UF&#39;, &#39;geometry&#39;], dtype=&#39;object&#39;)</code></pre>
<p>Olha que interessante! Para cada estado, há seu nome, a região a que pertence, sua Unidade da Federação (UF) e o código desta UF. Agora que já sabemos como estão nossos dados, vamos voltar um pouco na coluna <code>geometry</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(gdf[<span class="st">&quot;geometry&quot;</span>].head(<span class="dv">5</span>))</code></pre></div>
<pre><code>## 0    POLYGON ((-73.80098 -7.11145, -73.74084 -7.143...
## 1    MULTIPOLYGON (((-36.39119 -10.50082, -36.39864...
## 2    MULTIPOLYGON (((-51.37380 -0.37053, -51.37337 ...
## 3    POLYGON ((-73.80098 -7.11145, -73.80106 -7.111...
## 4    MULTIPOLYGON (((-46.32975 -13.25248, -46.33072...
## Name: geometry, dtype: geometry</code></pre>
<p>Entenda, a geometria escolhida para representar cada um dos estados do Brasil foi o polígono, e isto é possível de visualizar na coluna <code>geometry</code>. Outro fato importante sobre esta coluna é que, ela não precisa ter este nome, ele é definido automaticamente pelo GeoPandas para que as coisas sejam padronizadas e fiquem mais simples, mas, caso eu queira alterar, posso fazer isto facilmente da seguinte forma.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">gdf <span class="op">=</span> gdf.rename_geometry(<span class="st">&quot;geometria&quot;</span>)</code></pre></div>
<p>Ao fazer isto, vamos visualizar as colunas do <code>GeoDataFrame</code> alterado.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(gdf.columns)</code></pre></div>
<pre><code>## Index([&#39;ESTADOS&#39;, &#39;REGIAO&#39;, &#39;COD_UF&#39;, &#39;UF&#39;, &#39;geometria&#39;], dtype=&#39;object&#39;)</code></pre>
<p>Mas, e se nos dados que eu estiver carregando existirem mais de uma coluna de representações espaciais, como o GeoPandas entende qual deve ser utilizada? Bem, por padrão ele escolherá a primeira delas e a tratará como a coluna <code>geometry</code> do conjunto de dados, porém se eu quiser fazer a alteração, também é possível.</p>
<p>Primeiro, vamos aprender a identificar como o GeoPandas mostra a coluna que ele está utilizando como padrão, para isto o atributo <code>geometry</code> é utilizado.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(gdf.geometry.head(<span class="dv">5</span>))</code></pre></div>
<pre><code>## 0    POLYGON ((-73.80098 -7.11145, -73.74084 -7.143...
## 1    MULTIPOLYGON (((-36.39119 -10.50082, -36.39864...
## 2    MULTIPOLYGON (((-51.37380 -0.37053, -51.37337 ...
## 3    POLYGON ((-73.80098 -7.11145, -73.80106 -7.111...
## 4    MULTIPOLYGON (((-46.32975 -13.25248, -46.33072...
## Name: geometria, dtype: geometry</code></pre>
<p>Este atributo devolve os dados da coluna padrão de geometrias. Vamos ver qual é o nome da coluna de onde ele retira tais dados.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(gdf.geometry.name)</code></pre></div>
<pre><code>## geometria</code></pre>
<p>O nome é exatamente o mesmo da coluna que renomeamos! Vamos trocar esta coluna padrão, para fazer este teste, vou duplicar a coluna que contém as geometrias, porém cada uma terá um nome.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">gdf[<span class="st">&quot;geometria_dois&quot;</span>] <span class="op">=</span> gdf[<span class="st">&quot;geometria&quot;</span>]

<span class="bu">print</span>(gdf.columns)</code></pre></div>
<pre><code>## Index([&#39;ESTADOS&#39;, &#39;REGIAO&#39;, &#39;COD_UF&#39;, &#39;UF&#39;, &#39;geometria&#39;, &#39;geometria_dois&#39;], dtype=&#39;object&#39;)</code></pre>
<p>Feito isto, vamos alterar a coluna padrão de geometrias</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">gdf <span class="op">=</span> gdf.set_geometry(<span class="st">&quot;geometria_dois&quot;</span>)</code></pre></div>
<p>Ao visualizar o resultado, percebemos que a mudança foi realizada com sucesso.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(gdf.geometry.name)</code></pre></div>
<pre><code>## geometria_dois</code></pre>
<blockquote>
<p>A diferença entre o método <code>rename_geometry</code> e <code>set_geometry</code> está no ponto em que, a <code>set_geometry</code> altera a coluna que está sendo considerada como padrão para geometrias, enquanto a <code>rename_geometry</code> altera o nome da coluna padrão de geometrias.</p>
</blockquote>
<p>Por fim, vamos visualizar a disposição destes dados em uma figura, para isto, utilizamos o método <code>plot</code>.</p>
<pre><code>gdf.plot()</code></pre>
<p><img src="intro-analise-de-dados-espaciais_files/figure-html/unnamed-chunk-110-1.png" /><!-- --></p>
<p>O ponto a ser entendido do método <code>plot</code> é que, ele utiliza a coluna de geometrias padrão para gerar a figura, então, caso haja alguma inconsistência neste coluna este método terá problemas. Esta lógica se aplica a todos os outros métodos do GeoPandas que utilizam a representação espacial para fazer as operações.</p>
<p>Vamos salvar os resultados em um arquivo <code>shapefile</code>, para isto, façamos a utilização do método <code>to_file</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">del</span> gdf[<span class="st">&quot;geometria&quot;</span>] <span class="co"># Removendo coluna extra de geometrias</span>

gdf.to_file(<span class="st">&#39;tmp/estados_do_brasil_editado.shp&#39;</span>)</code></pre></div>
<p>Não deixe de consultar a documentação do Pandas e do GeoPandas, por conta das bibliotecas trabalharem juntas, muitos formas de dados podem ser escritos e tratados, no GeoPandas é possível até mesmo ler dados diretamente de um banco de dados espacial (PostGres com PostGIS).</p>
</div>
<div id="manipulação-geométrica" class="section level3">
<h3><span class="header-section-number">3.2.3</span> Manipulação geométrica</h3>
<p>O GeoPandas oferece diferentes métodos para a manipulação dos dados espaciais carregados, esta seção fará a apresentação de alguns destes métodos.</p>
<blockquote>
<p>É importante lembrar que, todos estes métodos estão orientados a coluna de geometria padrão, vista na subseção anterior.</p>
</blockquote>
<p>As operações apresentadas nas subseções a seguir, são representadas por métodos e atributos das <code>GeoSeries</code> e dos <code>GeoDataFrames</code>.</p>
<div id="area" class="section level4">
<h4><span class="header-section-number">3.2.3.1</span> area</h4>
<p>Vamos começar com as operações de área, que de forma análoga ao nome, cálcula a área da geometria em questão. Vejamos a Figura abaixo que faz uma representação desta operação em diferentes formas geométricas.</p>
<div class="figure">
<img src="res/3_python/opgeom_area.svg" />

</div>
<p>O resultado da operação, devolve o cálculo da área, representado em vermelho na Figura acima. Para exemplificar, vamos utilizar o conjunto de dados dos estados do Brasil</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">estados_do_brasil <span class="op">=</span> gpd.read_file(<span class="st">&quot;../data/1_estados_do_brasil_shape/Brasil.shp&quot;</span>)</code></pre></div>
<blockquote>
<p>Lembre-se, este conjunto de dados está disponível no <a href="https://github.com/dataAt/introducao-analise-de-dados-espaciais/tree/master/data">repositório</a> do curso</p>
</blockquote>
<p>Depois de carregar os dados, vamos utilizar o atributo <code>area</code>, que realiza a operação e devolve a àrea para cada uma das linhas do conjunto de dados</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(estados_do_brasil.area.head(<span class="dv">5</span>)) <span class="co"># Exibindo somente as 5 primeiras</span></code></pre></div>
<pre><code>## 0     12.553132
## 1      2.285972
## 2     11.424936
## 3    128.108383
## 4     46.911114
## dtype: float64</code></pre>
<p>A área é devolvida na unidade de medida da projeção espacial utilizada no conjunto de dados, estes detalhes serão apresentados nas seções seguintes.</p>
</div>
<div id="bounds" class="section level4">
<h4><span class="header-section-number">3.2.3.2</span> bounds</h4>
<p>O atributo <code>bounds</code> devolve as coordenadas mínimas e máximas da região coberta pela geometria. Sua representação é feita na Figura abaixo.</p>
<div class="figure">
<img src="res/3_python/opgeom_bounds.svg" />

</div>
<p>Perceba que, para cada figura é criado um retângulo que a envolve (Também chamado de retângulo envolvente) e as coordenadas mínimas e máximas são retiradas desses. Vejamos um exemplo</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(estados_do_brasil.bounds.head(<span class="dv">5</span>))</code></pre></div>
<pre><code>##         minx       miny       maxx      maxy
## 0 -73.990943 -11.144489 -66.619331 -7.111453
## 1 -38.237442 -10.500822 -35.151669 -8.812208
## 2 -54.875779  -1.235830 -49.875779  4.437122
## 3 -73.801055  -9.814097 -56.097385  2.247063
## 4 -46.629029 -18.349041 -37.339928 -8.532272</code></pre>
</div>
<div id="centroid" class="section level4">
<h4><span class="header-section-number">3.2.3.3</span> centroid</h4>
<p>O atributo <code>centroid</code> devolve o ponto central da geometria. Sua representação é feita na Figura abaixo.</p>
<div class="figure">
<img src="res/3_python/opgeom_centroid.svg" />

</div>
<p>O ponto retornado para cada geometria é apresentado em vermelho. Vejamos um exemplo com o GeoPandas.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">centroids_dos_estados <span class="op">=</span> estados_do_brasil.centroid</code></pre></div>
<p>Se olharmos para o resultado teremos uma <code>GeoSeries</code> com um ponto para cada um dos estados, vamos visualizar estes pontos rapidamente.</p>
<pre><code>centroids_dos_estados.plot()</code></pre>
<p><img src="intro-analise-de-dados-espaciais_files/figure-html/unnamed-chunk-116-1.png" /><!-- --></p>
<p>Para fazermos um pequeno experimento, famos pegar a figura com os estados e fazer seu plot junto com os centroids.</p>
<pre><code>base = estados_do_brasil.plot()
centroids_dos_estados.plot(ax=base, marker=&quot;o&quot;, color=&quot;red&quot;)</code></pre>
<p><img src="intro-analise-de-dados-espaciais_files/figure-html/unnamed-chunk-117-1.png" /><!-- --></p>
</div>
<div id="buffer" class="section level4">
<h4><span class="header-section-number">3.2.3.4</span> buffer</h4>
<p>O método <code>buffer</code> cria um circulo entorno de um ponto, e pode ser aplicado em diferentes tipos de análises espaciais. Sua representação é feita na Figura abaixo.</p>
<center>
<img src="res/3_python/opgeom_buffer.svg" />
</center>
<p>Para testar esta operação, vamos utilizar os <code>centroids</code> extraídos na seção anterior.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">buffers <span class="op">=</span> centroids_dos_estados.<span class="bu">buffer</span>(<span class="dv">2</span>)</code></pre></div>
<p>Da mesma forma que outros métodos que trabalham com distâncias, os valores dependem diretamente das projeções espaciais utilizadas. Vamos fazer um plot do resultado gerado sob o mapa dos estados do Brasil.</p>
<pre><code>base = estados_do_brasil.plot()
base = buffers.plot(ax = base, color = &#39;yellow&#39;)

# Adicionando os centroids também, para testar =D
centroids_dos_estados.plot(ax = base, color = &#39;red&#39;)</code></pre>
<p><img src="intro-analise-de-dados-espaciais_files/figure-html/unnamed-chunk-119-1.png" /><!-- --></p>
</div>
<div id="envelope" class="section level4">
<h4><span class="header-section-number">3.2.3.5</span> envelope</h4>
<p>Por fim, o método <code>envelope</code> cria o mesmo retângulo envolve utilizado no atributo <code>bounds</code>, com a diferença que, neste caso a geometria é devolvida. A representação desta operação é feita na Figura abaixo.</p>
<center>
<img src="res/3_python/opgeom_envelope.svg" />
</center>
<p>Para testar, vamos pegar os buffers gerados anteriormente e então gerar seu retângulo envolvente.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">envelopes <span class="op">=</span> buffers.envelope</code></pre></div>
<p>Da mesma forma que nos demais, vamos visualizar o resultado.</p>
<pre><code>base = estados_do_brasil.plot()

envelopes.plot(ax = base, color = &#39;green&#39;)</code></pre>
<p><img src="intro-analise-de-dados-espaciais_files/figure-html/unnamed-chunk-121-1.png" /><!-- --></p>
</div>
</div>
<div id="seleção-e-filtro-de-dados" class="section level3">
<h3><span class="header-section-number">3.2.4</span> Seleção e filtro de dados</h3>
<p>O GeoPandas ainda fornece métodos para a seleção e filtros de dados baseados na posição espacial. Nesta seção veremos dois desses, que podem ser muito úteis nas mais diversas análises.</p>
<div id="distance" class="section level4">
<h4><span class="header-section-number">3.2.4.1</span> distance</h4>
<p>Vamos começar com o método <code>distance</code>, que calcula a distância entre duas geometrias. Sua operação é representada na Figura abaixo.</p>
<center>
<img src="res/3_python/opgeom_distance.svg" />
</center>
<p>Para testar esta operação, vamos carregar dois dados vetoriais, cada um representando um estado do Brasil.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">estado_maranhao <span class="op">=</span> gpd.read_file(<span class="st">&quot;../data/2_estado_sp_shape/shape_estado-sp.shp&quot;</span>)
estado_saopaulo <span class="op">=</span> gpd.read_file(<span class="st">&quot;../data/3_estado_ma_shape/shape_estado-ma.shp&quot;</span>)</code></pre></div>
<p>Vamos visualizar os dois juntos. Nesta visualização, para ela ter sentido, abaixo dos estados foi fazer o plot do mapa do Brasil.</p>
<pre><code>base = estados_do_brasil.plot()

base = estado_maranhao.plot(ax = base, color = &#39;green&#39;)
estado_saopaulo.plot(ax = base, color = &#39;yellow&#39;)</code></pre>
<p><img src="intro-analise-de-dados-espaciais_files/figure-html/unnamed-chunk-123-1.png" /><!-- --></p>
<p>Certo, vamos calcular a distância entre cada um deles.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">distancia <span class="op">=</span> estado_saopaulo.distance(estado_maranhao)

<span class="bu">print</span>(distancia)</code></pre></div>
<pre><code>## 0    9.809695
## dtype: float64</code></pre>
<p>Feito, com isto tem-se a distância entre as duas geometrias, que neste caso representa os estados do Maranhão e São Paulo. Esta mesma operação pode ser utilizada como uma forma de consulta aos dados, por exemplo, buscar estados que estejam a X de distância de outro.</p>
</div>
<div id="contains-1" class="section level4">
<h4><span class="header-section-number">3.2.4.2</span> contains</h4>
<p>O método <code>contains</code> verifica se uma geometria está contida em outra, sua representação visual é apresentada abaixo .</p>
<center>
<img src="res/3_python/opgeom_contains.svg" />
</center>
<p>Vamos fazer um teste da operação com o estado do Amazonas, verificando se sua geometria está contida nas nos dados de estados do Brasil.</p>
<p>Primeiro, vamos retirar do <code>GeoDataFrame</code> as informações do estado do Amazonas, para isto aplicamos um filtro booleano, herdado do Pandas.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">estado_amazonas <span class="op">=</span> estados_do_brasil[estados_do_brasil[<span class="st">&quot;ESTADOS&quot;</span>] <span class="op">==</span> <span class="st">&quot;Amazonas&quot;</span>] <span class="co"># Indexação booleana</span></code></pre></div>
<p>Agora vamos verificar se o estado está contido em alguma geometria dos estados do Brasil.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">amazonas_esta_presente <span class="op">=</span> estados_do_brasil.contains(estado_amazonas)

<span class="bu">print</span>(amazonas_esta_presente.head(<span class="dv">10</span>))</code></pre></div>
<pre><code>## 0    False
## 1    False
## 2    False
## 3     True
## 4    False
## 5    False
## 6    False
## 7    False
## 8    False
## 9    False
## dtype: bool</code></pre>
<p>Veja que em uma das linhas apareceu <code>True</code>, isto indica que a geometria do estado do Amazonas está contida nesta, que se formos olhar a linha do <code>GeoDataFrame</code> com os dados do estado, indica exatamente a linha do estado do Amazonas.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="bu">print</span>(estados_do_brasil[amazonas_esta_presente])</code></pre></div>
<pre><code>##     ESTADOS REGIAO  COD_UF  UF                                           geometry
## 3  Amazonas  Norte    13.0  AM  POLYGON ((-73.80098 -7.11145, -73.80106 -7.111...</code></pre>
</div>
<div id="intersects-1" class="section level4">
<h4><span class="header-section-number">3.2.4.3</span> intersects</h4>
<p>Por fim, na parte de seleção através dos dados espaciais, vamos testar o método <code>intersects</code>, que verifica se uma geometria faz intersecção com outra. Vale lembrar que, é tido como uma intersecção, quando um objeto cruza de alguma maneira, seu limite e seu interior com outro objeto. A operação pode ser vista abaixo.</p>
<center>
<img src="res/3_python/opgeom_intersects.svg" />
</center>
<p>Para realizar este teste, vamos carregar um arquivo que contém todos rios do nosso país. E então verificar quais desses fazem intersecção com o estado do Pará.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">rios_brasil <span class="op">=</span> gpd.read_file(<span class="st">&quot;../data/4_rios_brasil/Brasil_rios.shp&quot;</span>)</code></pre></div>
<p>Antes de continuar, vamos visualizar os dados, junto aos estados do Brasil.</p>
<pre><code>base = estados_do_brasil.plot(color = &quot;gray&quot;)
rios_brasil.plot(ax = base, color = &#39;red&#39;)</code></pre>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">base <span class="op">=</span> estados_do_brasil.plot(color <span class="op">=</span> <span class="st">&quot;gray&quot;</span>)
rios_brasil.plot(ax <span class="op">=</span> base, color <span class="op">=</span> <span class="st">&#39;red&#39;</span>)

plt.show()</code></pre></div>
<p><img src="intro-analise-de-dados-espaciais_files/figure-html/unnamed-chunk-129-1.png" /><!-- --></p>
<p>Agora vamos pegar somente o estado do Pará do conjunto de estados e verificar quais rios fazem intersecção com ele.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">estado_para <span class="op">=</span> estados_do_brasil[estados_do_brasil[<span class="st">&quot;ESTADOS&quot;</span>] <span class="op">==</span> <span class="st">&quot;Pará&quot;</span>]
rios_intersect_para <span class="op">=</span> rios_brasil.intersects(estado_para)

<span class="bu">print</span>(rios_intersect_para.head(<span class="dv">5</span>))</code></pre></div>
<pre><code>## 0    False
## 1    False
## 2    False
## 3    False
## 4    False
## dtype: bool</code></pre>
<p>O resultado é uma lista booleana, desta forma, vamos filtrar o conjunto de dados de rios com este índice, e então verificar quais deles fazem intersecção com o estado do Pará.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">rios_para <span class="op">=</span> rios_brasil[rios_intersect_para]</code></pre></div>
<p>Com os dados separados, vamos fazer um plot para melhor visualizar o resultado. Neste plot vamos utilizar o <code>matplotlib</code>, para criar vários subplots.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt

<span class="co"># Criando figura e os subplots</span>
fig, (ax1, ax2) <span class="op">=</span> plt.subplots(ncols<span class="op">=</span><span class="dv">2</span>)

base <span class="op">=</span> estados_do_brasil.plot(ax <span class="op">=</span> ax1, color <span class="op">=</span> <span class="st">&#39;blue&#39;</span>)
rios_para.plot(ax <span class="op">=</span> base, color <span class="op">=</span> <span class="st">&#39;red&#39;</span>)

base <span class="op">=</span> estado_para.plot(ax <span class="op">=</span> ax2, color <span class="op">=</span> <span class="st">&#39;gray&#39;</span>)
rios_para.plot(ax <span class="op">=</span> base, color <span class="op">=</span> <span class="st">&#39;red&#39;</span>)

plt.show()</code></pre></div>
<p><img src="intro-analise-de-dados-espaciais_files/figure-html/unnamed-chunk-132-1.png" /><!-- --></p>
<p>Veja que esta operação verificou somente aqueles que fazem intersecção com as fronteiras, não indicando que está contido ou próximo ao estado.</p>
</div>
</div>
<div id="manipulação-de-projeções" class="section level3">
<h3><span class="header-section-number">3.2.5</span> Manipulação de projeções</h3>
<p>Uma operação muito importante quando se está trabalhando dados espaciais é a manipulação de suas projeções, estas que como explicado no capítulo anterior, fazem as representações das geometrias no espaço, o GeoPandas fornece um método muito simples para tal operação, o <code>to_crs</code>, que altera a projeção dos dados sem grandes problemas.</p>
<center>
<img src="res/3_python/opgeom_tocrs.svg" />
</center>
<p>Este foi o capítulo sobre GeoPandas e suas facilidades de uso 🌟, não deixe de consultar a documentação oficial e fazer seus testes 💫.</p>

</div>
</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="r.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="introdução-ao-postgis.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/clipboard.min.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-clipboard.js"></script>
<script>
gitbook.require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"linkedin": false,
"weibo": false,
"instapaper": false,
"vk": false,
"all": ["facebook", "twitter", "linkedin", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": null,
"text": null
},
"history": {
"link": null,
"text": null
},
"view": {
"link": null,
"text": null
},
"download": null,
"toc": {
"collapse": "subsection"
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    var src = "";
    if (src === "" || src === "true") src = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:")
      if (/^https?:/.test(src))
        src = src.replace(/^https?:/, '');
    script.src = src;
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
